## 第四章 指令系统

### 4.1 本章大纲要求与核心考点

#### 4.1.1 大纲内容

（一）指令系统的基本概念

（二）指令格式

（三）寻址方式

（四）数据的对齐和大/小端存放方式

（五）CISC 和 RISC 的基本概念

（六）高级语言程序与机器级代码之间的对应

1. 编译器、汇编器和链接器的基本概念
2. 选择结构语句的机器级表示
3. 循环结构语句的机器级表示
4. 过程（函数）调用对应的机器级表示

#### 4.1.2 核心考点

​        本章内容是也是考研考察的一个重点，一般会与第二章、第三章和第五章进行结合，往往以综合应用题的形式出现。而常见的寻址方式很容易以单项选择题的形式进行考察。

​        需要重点掌握的内容包括：

- 指令的格式及相关概念，定长与扩展操作码格式。
- 常见的寻址方式、特点及有效地址的计算。
- 常用的汇编指令，过程调用、选择语句和循环语句的机器级表示，标志位及其使用。
- CISC 和 RISC 的基本概念，CISC 和 RISC 的比较。

#### 4.1.3 真题分布

  <table style="text-align:center">
      <tr>
          <th rowspan="2">考点</th>
          <th colspan="2">考查次数</th>
      </tr>
      <tr>
          <th>单项选择题</th>
          <th>综合应用题</th>
      </tr>
      <tr>
          <td>常见寻址方式</td>
          <td>9</td>
          <td>5</td>
      </tr>
      <tr>
          <td>指令格式</td>
          <td>4</td>
          <td>6</td>
      </tr>
      <tr>
          <td>程序的机器级代码表示</td>
          <td>0</td>
          <td>2</td>
      </tr>
      <tr>
          <td>CISC 和 RISC</td>
          <td>1</td>
          <td>1</td> 
      </tr>



### 4.2 指令和指令格式

​		计算机是通过连续执行一条条机器语言语句，而实现自动工作的。习惯上就把每一条机器语言的语句称为 **指令**，而把全部机器指令的集合称为机器的 **指令系统**。

- **指令**（机器指令）是指计算机执行某种操作的机器语言命令。
- 一台计算机的所有指令的集合构成该计算机的 **指令系统**，也称 **指令集**。

​		指令系统是计算机的主要属性，位于硬件和软件的交界面上。

#### 4.2.1 指令的基本格式

​		指令由 **操作码** 和 **地址码（操作数地址）** 两部分组成。

![](E:\source\jk-english\英语语法初级\图片\4_1_指令基本格式.png)

- **操作码**：指出指令执行什么操作和具有何种功能。例如，指出是算术加运算，还是减运算；是程序转移，还是返回操作。
- **地址码**：指岀被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。

#### 4.2.2 指令字长		

​		**指令字长** 是指一条指令中所包含的二进制代码的位数，它取决于操作码的长度、操作数地址的长度和操作数的个数。不同机器的指令字长是不同的，指令字长通常取 8 的整数倍。

​		按照字长是否可变，又可以将指令系统分为 **定长指令字结构** 和 **变长指令字结构**。

##### 1. 定长指令字结构

​		在一个指令系统中，若所有指令的长度都是相等的，称为 **定长指令字结构（定字长指令）**。

​		早期的计算机都是定长指令字结构，而且指令字长、机器字长、存储字长全部相等；这样每次访问某个存储单元，就可以取出一个完整的指令或者数据。

![](E:\source\jk-english\英语语法初级\图片\4_2_定长指令字结构.png)

​		定字长指令的执行速度快，控制简单。精简指令系统计算机（Reduced Instruction Set Compter，RISC）采用定字长指令。

##### 2. 变长指令字结构

​		随着计算机的发展，存储容量不断增大，要求处理的数据类型也越来越多，指令字长发生了很大变化。一台计算机的指令系统可以采用不同长度的指令，比如单字长指令、多字长指令。

​		若指令系统中各种指令的长度随指令功能而异，就称为 **变长指令字结构（变字长指令）**。由于主存是按字节编址的，所以指令字长多为字节的整数倍。

![](E:\source\jk-english\英语语法初级\图片\4_3_变长指令字结构.png)

​		控制变长指令的电路会比较复杂，而且多字长指令需要多次访问主存才能取出一条完整指令，导致了 CPU 速度降低。

​		原则上讲，短指令比长指令好，因为短指令能节省存储空间，提高取指令的速度，但也有很大的局限性。长指令占用更多的存储空间，取指令的时间也会更长，但其能扩大寻址范围或可带多个操作数。 如果长、短指令在同一机器中混合使用，就会给指令系统带来很大的灵活性。为了提高指令运行速度、节省存储空间，一般会尽可能地把常用的指令设计成单字长或者短字长的格式。

​		复杂指令系统计算机 （Complex Instruction Set Compter，CISC）采用变字长指令。

#### 4.2.3 地址码

​		**地址码** 用来指出指令操作涉及到的数据或指令具体保存的位置，可以包括：

- 源操作数的地址（一个或两个）
- 操作结果的地址
- 下一条指令的地址

​		这里的 “地址” 一般指主存地址，也可以是寄存器的地址，甚至可以是 I/O 设备的地址。

​		我们以主存地址为例，分析一下地址码的分配。根据地址码字段的数量不同，可以把指令再做分类：

##### 1. 四地址指令

​		地址码字段最多的指令，可以包含所有的信息，共有四个地址字段：

![](E:\source\jk-english\英语语法初级\图片\4_4_四地址指令.png)

​		其中 OP 是操作码；地址码 A~1~ 为第一操作数地址，A~2~ 为第二操作数地址，A~3~ 为结果地址，A~4~ 为下一条指令的地址。

​		这一指令完成的操作可以写作：
$$
(A_1)OP(A_2)→A_3
$$
​		对 A~1~ 和 A~2~ 中存放的数据执行 OP 操作，得到的结果填入 A~3~ ，然后再跳转到 A~4~ 位置执行下一条指令。后续指令地址可以任意填写。

![](E:\source\jk-english\英语语法初级\图片\4_5_四地址指令分析.png)

​		假设采用定字长指令结构，指令字长为 32 位，操作码 OP 固定为 8 位。这样，每个地址码就应该占据 6 位，那么能够寻址的地址范围为 2^6^ = 64。

​		这里如果都是主存地址，那么完成这样的一条四地址指令，需要访问主存 4 次（取指令 → 取操作数 A~1~ → 取操作数 A~2~ → 结果写入 A~3~）。

##### 2. 三地址指令

​		程序中大多数指令都是顺序执行的，而程序计数器 PC 存放了当前要执行指令的地址，每次执行完会自动计算下一条指令的地址（“加 1”）；所以一般并不需要在指令中直接给出下一条指令的地址，A~4~ 可以省去，这样就得到了三地址指令。

​										![](E:\source\jk-english\英语语法初级\图片\4_6_三地址指令.png)

​		跟四地址指令一样，它也可以完成操作：
$$
(A_1)OP(A_2)→A_3
$$
​		后续的指令地址隐含在 PC 中。如果指令字长仍为 32 位、操作码为 8 位，那么每个地址码也可以占据 8 位，能够寻址的地址范围为 2^8^ = 256。当然，完成这样一条指令同样需要 4 次访存。

##### 3. 二地址指令

​		如果将操作的结果直接保存在某个操作数地址对应的存储单元，就又可以在指令中节省一个地址 A~3~，这样就得到了二地址指令。

![](E:\source\jk-english\英语语法初级\图片\4_7_二地址指令.png)

​		它表示执行的操作为：
$$
(A_1)OP(A_2)→A_1
$$
​		这里 A~1~ 既代表第一个源操作数的地址，也代表本次运算结果的存放地址。这种情况下，完成这一条指令同样需要 4 次访存（取指令 → 取操作数 A~1~ → 取操作数 A~2~ → 结果写入 A~1~）。

​		由于访存开销比较大，计算机运行过程中，可以将中间计算结果暂存在 CPU 的寄存器（如 ACC）中，这样就节省了最后写入主存的过程。这时的二地址指令表示执行的操作为：
$$
(A_1)OP(A_2)→ACC
$$
​		这种情况下，完成指令只需要 3 次访存。如果指令字长仍为 32 位、操作码为 8 位，那么每个地址码可以占据 12 位，能够寻址的地址范围为 2^12^ = 4K。

##### 4. 一地址指令

​		自然可以想到，如果把二地址指令的两种情况结合起来，把某个操作数放在寄存器中，同时计算结果也放在寄存器中，那么就又可以节省一个地址了；这就是一地址指令。

![](E:\source\jk-english\英语语法初级\图片\4_8_一地址指令.png)

​		它表示执行的操作为：
$$
(ACC)OP(A_1)→ACC
$$
​		这里第一个操作数存放在 ACC 中，第二个操作数地址为 A~1~，运算结果仍存放在 ACC 中。这样，完成指令只需要 2 次访存（取指令 → 取操作数 A~1~）。

​		当然，上面所讨论的都是需要两个操作数的情况；一些特殊的操作，可能只需要一个操作数，比如按位取反、自增自减操作。这时表示执行的操作为：
$$
OP(A_1)→A_1
$$
​		因为得到的结果还要再写回到对应地址中，所以需要 3 次访存（取指令 → 取操作数 A~1~ → 结果写入 A~1~）。如果指令字长仍为 32 位、操作码为 8 位，那么地址码可以占据 24 位，能够寻址的地址范围为 2^24^ = 16M。

##### 5. 零地址指令

​		在指令系统中，还有一种指令是没有地址码的，这就是零地址指令。零地址指令中只有操作码也可以分两种情况：

- 没有操作数的指令，比如空操作（NOP）、停机（HLT）；
- 有一个隐含操作数的指令，比如子程序返回（RET）、中断返回（IRET），这类操作利用了栈数据结构，操作数的地址就隐含在堆栈指针（SP）中。

#### 4.2.4 操作码

​		操作码的位数就代表了机器的操作种类，也就是机器指令集中的指令条数。操作码的长度可以是固定的，也可以是变化的。根据操作码长度是否可变，可以分为 **定长操作码** 和 **变长操作码** 两种指令格式。

##### 1. 定长操作码指令格式

​		**定长操作码指令**，是在指令字的最高位部分分配固定的若干位（定长）表示操作码。一般 n 位操作码字段的指令系统最大能够表示 2^n^ 条指令。

![](E:\source\jk-english\英语语法初级\图片\4_9_定长操作码指令.png)

​		这种指令格式便于计算机硬件设计，指令译码和识别时间短，广泛应用于字长较长的、大中型计算机和超级小型计算机以及 RISC（Reduced Instruction Set Compter，精简指令集计算机）中。当计算机字长为 32 位或更长时，这是常规做法。

##### 2. 扩展操作码指令格式

​		**可变长度操作码指令**，是指全部指令的操作码字段的位数不固定，且分散地放在指令字的不同位置。显然，这将增加指令译码和分析的难度，使控制器的设计复杂化。

​		常见的可变长度操作码是 **扩展操作码**。在指令字长一定的条件下，操作码的长度随地址数的减少而增加，不同地址数的指令可以具有不同长度的操作码。

​		在设计扩展操作码指令时，需要注意两点：

- 不允许短操作码是长操作码的前缀；
- 各指令的操作码一定不能重复。

​		下面就是一种扩展操作码的示例。指令字长为 16 位，前 4 位为基本操作码字段 OP，另有 3 个 4 位的地址字段分别为 A~1~、A~2~、A~3~。

![](E:\source\jk-english\英语语法初级\图片\4_10_扩展操作码示例.png)

​		4 位基本操作码若全部用于三地址指令，则有 16 条。如果考虑到需要扩展到较少地址的指令，则将三地址指令减为 15 条，1111 留作扩展操作码使用；二地址指令为 15 条，1111 1111留作扩展操作码使用；一地址指令为 15 条，1111 1111 1111 留作扩展操作码使用；零地址指令为 16 条。

​		除了这种安排以外，还有其他多种扩展方法，如形成 15 条三地址指令、12 条二地址指令、63 条一地址指令和 16 条零地址指令，共 106 条指令；或者 12 条三地址指令、61 条二地址地址、47 条一地址指令和 16 条零地址指令。

<img src="C:/Users/18133/Desktop/课件/pictures/4_11_扩展操作码示例（二）.png" style="zoom:90%;" />

​		在通常情况下，对使用频率较高的指令分配较短的操作码，对使用频率较低的指令分配较长的操作码，从而尽可能减少指令译码和分析的时间。

#### 4.2.5 指令的操作数类型和操作类型

##### 1. 操作数类型

​		计算机中常见的操作数类型有数字、地址、字符、逻辑数据等。

- 数字：计算机中常见的数字有定点数、浮点数和十进制数，它们分别用不同格式的二进制编码来表达。
- 地址：本质上也是一种数据，很多时候需要对操作数地址进行计算，可以认为是一个无符号整数。
- 字符：文本或者字符串也是一种常见的数据形式。计算机不能直接存储和传送数据，需要按一定规则对字符进行编码；广泛使用的是 ASCII 编码。
- 逻辑数据：除算术运算外，计算机还经常需要进行逻辑运算，此时二进制码中的 0 和 1 就应该被看作逻辑上的 “假” 和 “真”，参与逻辑与或非运算。这样的数据就是 “逻辑数据”。

##### 2. 指令的操作类型

​		设计指令系统时必须考虑应提供哪些操作类型，指令操作类型按功能可分为以下几种。

​	**（1）数据传送**

​		数据传送指令通常有寄存器之间的数据传送（MOV）、从内存单元读取数据到 CPU 寄存器 （LOAD）、从CPU 寄存器写数据到内存单元（STORE）等。

​	**（2）算术和逻辑运算**

​		这类指令主要有加（ADD）、减（SUB）、比较（CMP）、乘（MUL）、除（DIV）、加1 （INC）、减1 （DEC）、与（AND）、或（OR）、取反（NOT）、异或（XOR）等。

​	**（3）移位操作**

​		移位操作指令主要有算术移位指令、逻辑移位指令、循环移位指令等。移位操作经常被用来替代简单的乘/除法运算。

​	**（4）转移操作**

​		转移操作指令主要有无条件转移（JMP）指令、条件转移（BRANCH）指令、调用（CALL）指令、 返回（RET）指令、陷阱（TRAP）指令等。

​		**① 无条件转移指令**

​		在任何情况下都执行转移操作，可以直接把程序转移到下一条要执行指令的地址。

​		例如：“ JMP  X ”，就是无条件跳转到地址 X 去执行下一条指令。

​		**② 条件转移指令**

​		条件转移指令仅在满足特定条件时才执行转移操作，转移条件一般是一个或几个标志位的值。这些标志位是某些操作的结果，也叫做 “条件码”。例如：

- 零标志位（ZF），当结果为 0 时，ZF = 1；
- 负标志位（SF），结果为负时，SF = 1；
- 溢出标志位（OF），结果溢出时，OF = 1；
- 进位标志位（CF），最高位有进位时，CF = 1；
- 奇偶标志位（PF），结果为偶数时，PF = 1

​		这样，

​		“ JZ  X ”，就表示判断结果是否为 0：如果为 0 就跳转到 X，如果不为 0 则继续顺序执行；

​		“ JO  Y ”，就表示判断结果是否溢出：如果溢出就跳转到 Y，如果没有溢出则继续顺序执行；

​		“ JC  Z ”，就表示判断结果最高位是否有进位：如果有进位就跳转到 Z，如果没有则继续顺序执行。

​		**③ 调用和返回指令**

​		调用指令可以实现从一个程序到另一个程序的转移操作。

​		程序中，有些特定的程序段会被反复调用。为了避免重复编写，可以将这些程序段设定为 **子程序**；需要调用时，只需要执行子程序调用指令就可以了。还有一些子程序是系统提供的，用户也可以直接调用。

​		**调用指令（CALL）**一般与 **返回指令（RETURN）**配合使用。CALL 用来从当前程序位置转移至子程序的入口，RETURN 则用于子程序执行完后重新返回到原程序的调用点。

![](E:\source\jk-english\英语语法初级\图片\4_12_调用和返回指令.png)

​		调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行。

​		④ 陷阱（Trap）指令

​		陷阱其实是一种意外事故引发的中断。比如，电压不稳定、I/O 设备发生故障、用户使用未定义的指令、除数为 0 等等各种意外事件，都会导致计算机不能继续正常工作。此时计算机就发出陷阱信号，暂定当前程序的执行，转入故障处理程序进行相应的处理。

​		计算机的陷阱指令一般不提供给用户使用，而是作为隐指令，在出现故障时由 CPU 自动产生并执行。

​	**（5）输入输出操作**

​		对于 I/O 单独编址的计算机，通常设有 I/O 指令。这类指令用于 CPU 与外部设备交换数据或传送控制命令及状态信息。

​	（6）其它操作

​		计算机中还有一些通用的控制操作，比如等待（WAIT）、停机（HLT）、空操作（NOP）、开关中断、置条件码等，都有相应的指令来完成。

### 4.3 寻址方式

​		寻址方式是寻找指令或操作数有效地址的方式，也就是指确定本条指令的数据地址，以及下一条将要执行的指令地址的方法。

​		寻址方式分为指令寻址和数据寻址两大类。

#### 4.3.1 指令寻址

​		指令寻址是指寻找下一条将要执行的指令地址。指令寻址方式有两种：一种是顺序寻址方式，另一种是跳跃寻址方式。

- 顺序寻址：可通过 **程序计数器（PC）**加1，自动形成下一条指令的地址。
- 跳跃寻址：通过 **转移类指令** 实现。跳跃寻址是指下一条指令的地址码不是由 PC 给出的，而是本条指令给出的。

![](E:\source\jk-english\英语语法初级\图片\4_13_指令寻址方式.png)

​		注意：这里所说的 “ PC 加1 ” 并不是 PC 一定会加 “1” 这个数值，而是要加当前指令占据的地址长度，从而总能得到下一条指令的地址；例如，如果机器按字节编址，当前指令字长是 4 个字节，那么执行这条指令后 PC = PC + 4。

#### 4.3.2 数据寻址

​		数据寻址是指确定本条指令中所有操作数的地址，即寻找指令要操作的数据的地址。		

​		指令中的地址字段并不一定代表操作数的真实地址，称为形式地址（A）。结合形式地址和寻址方式，可计算出操作数在存储器中的真实存储地址，这一地址称为有效地址（EA）。

​		由于地址字段表达的含义不同，可以有多种不同的寻址方式：比如 **直接寻址**、**间接寻址**、**寄存器寻址 **等。此外，如果通过将某个寄存器内容与一个形式地址相加而生成有效地址，这种方式称为 **偏移寻址**。偏移寻址又包括**基址寻址**、**变址寻址** 和 **相对寻址**。

​		数据寻址方式的种类较多，通常在指令中设一个字段，用来指明属于哪种寻址方式。由此可得指令的格式如下：

![](E:\source\jk-english\英语语法初级\图片\4_14_加寻址特征的一地址指令.png)

![](E:\source\jk-english\英语语法初级\图片\4_15_加寻址特征的二地址指令.png)

​		操作码的位数决定了指令的条数，寻址特征和形式地址共同决定了可寻址的范围。

- 若为立即寻址，则形式地址的位数决定了数的范围。
- 若为直接寻址，则形式地址的位数决定了可寻址的范围。
- 若为寄存器寻址，则形式地址的位数决定了通用寄存器的最大数量。
- 若为寄存器间接寻址，则寄存器字长决定了可寻址的范围。

​		下面是常见数据寻址方式的详细介绍。

##### 1. 立即寻址

​		指令的地址字段指出的不是操作数的地址，而是操作数本身，称为 **立即寻址**，又称为 **立即数寻址**。 数据采用补码形式存放。

![](E:\source\jk-english\英语语法初级\图片\4_16_立即寻址.png)

​		上面图中 # 表示立即寻址特征，A 就是操作数本身。

- 优点：指令在执行阶段不访问主存，指令执行速度快。
- 缺点：A的位数限制了立即数的范围，只适合操作数较小的情况。

##### 2. 直接寻址

​		指令格式的地址字段中直接指出操作数在内存中的地址，就称为 **直接寻址**。即
$$
EA = A
$$
![](E:\source\jk-english\英语语法初级\图片\4_17_直接寻址.png)

- 优点：指令简单，不需要专门计算操作数的地址，指令在执行阶段仅访问一次主存。

- 缺点：A 的位数决定了操作数的寻址范围，操作数的地址不易修改。

##### 3. 间接寻址

​		**间接寻址 **是相对于直接寻址而言的，是指指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数地址所在的存储单元地址；也就是 “地址的地址”，即 
$$
EA = (A)
$$
​		这里用（A）来表示地址为 A 的存储单元所存放的数据。

​		![](E:\source\jk-english\英语语法初级\图片\4_18_间接寻址.png)

​		间接寻址也可以分为多次进行，简称 **多次间址**。对于两次间接寻址，地址 A 存储的内容 A~1~ 还不是有效地址 EA，地址 A~1~ 对应的存储单元所存储的内容才是 EA。这时可以用存储字的首位来标记间接寻址是否结束：存储字首位为 “1” 时，说明还需要继续寻址；为 “0” 时，寻址结束，当前存储字存放的就是 EA。

- 优点：可扩大寻址范围（有效地址 EA 的位数大于形式地址 A 的位数）；便于编制程序。
- 缺点：指令在执行阶段要多次访存（一次间址需两次访存，多次间址需多次访存)。

##### 4. 隐含寻址

​		**隐含寻址** 是指指令字中不直接给出操作数的地址，而是隐含在某个寄存器中（通过操作码表示）。比如，一地址指令中，对于加法操作就可以只给出一个操作数的地址，而把另一个操作数放在 ACC 中；这时 ACC 就是另一个操作数的地址。

![](E:\source\jk-english\英语语法初级\图片\4_19_隐含寻址.png)

​		因为隐含寻址可以省去指令字中的一个地址，所以这种方式可以缩短指令字长，在计算机的指令集中被广泛使用。

##### 5. 寄存器寻址

​		**寄存器寻址** 的指令在执行时所需的操作数来自寄存器，运算结果也写回寄存器；地址码字段直接指出了寄存器的编号，即
$$
EA = R_i
$$
​		这样，指令执行期间不需要访问主存，减少了执行时间；而且计算机中寄存器数量是有限的，所以地址字段只需要用很少的二进制位指明寄存器编号即可，节省了存储空间。因此寄存器寻址在计算机被广泛应用。

![](E:\source\jk-english\英语语法初级\图片\4_20_寄存器寻址.png)

- 优点：指令在执行阶段不访问主存，只访问寄存器，指令字短且执行速度快。

- 缺点：寄存器的价格昂贵，且数量有限。


##### 6. 寄存器间接寻址

​		如果寄存器中不是直接给出操作数，而是操作数的内存地址，那么就称为 **寄存器间接寻址**。即 
$$
EA = (R_i)
$$
​		这是寄存器寻址和间接寻址的结合。跟寄存器寻址相比，指令的执行阶段还需要访问主存；跟间接寻址相比，则可以少一次对主存的访问。

![](E:\source\jk-english\英语语法初级\图片\4_21_寄存器间接寻址.png)

- 优点：获得操作数地址的速度较快；寄存器编号较短，可有效减少操作数字段的位数。

- 缺点：寄存器数量有限；指令的执行阶段需要访问主存（因为操作数在主存中）。

##### 7. 基址寻址

​		**基址寻址** 是一种偏移寻址的方式，需要设有基址寄存器 BR ；将基址寄存器 BR 的内容（基地址）加上指令中的形式地址，就可以形成操作数的有效地址。即
$$
EA = (BR) + A
$$
​		其中基址寄存器既可采用专用寄存器，也可采用通用寄存器。采用专用基址寄存器 BR ，使用时不用明确指出，只需要指令中的寻址特征反映出是基址寻址即可，这是 **隐式** 基址寄存器；对应地，如果采用通用寄存器，则需要用户明确指出用哪个寄存器作为基址寄存器，这是 **显式** 基址寄存器。

![](E:\source\jk-english\英语语法初级\图片\4_22_基址寻址.png)

- 优点：可扩大寻址范围；有利于多道程序设计和浮动程序编制。

- 缺点：偏移量（形式地址 A）的位数较短。


##### 8. 变址寻址

​		**变址寻址** 和基址寻址极为相似，需要设有变址寄存器 IX；将变址寄存器 IX 的内容加上指令中的形式地址，就可以形成操作数的有效地址。即
$$
EA = (IX) + A
$$
​		只要变址寄存器的位数足够，也可以扩大操作数的寻址范围。变址寄存器同样可以采用隐式和显式两种方式。

![](E:\source\jk-english\英语语法初级\图片\4_23_变址寻址.png)

​		不过从本质上讲，变址寻址和基址寻址还是有较大区别的。

- 基址寄存器是面向 **操作系统** 的，主要用于为程序或数据分配存储空间，其内容由操作系统或管理程序确定，在程序的执行过程中其值不可变，而指令字中的 A 是可变的；
- 变址寄存器的内容是由 **用户设定** 的，在程序执行过程中其值可变，而指令字中的 A 是不可变的。变址寻址主要用于处理数组问题。

​		例如，某个数组 a 内有 N 个数据元素，在主存中存放的首地址为 D。那么如果要对数组所有元素求和，可以通过直接寻址的方式依次叠加得到结果，写成汇编语言程序如下：

![](E:\source\jk-english\英语语法初级\图片\4_24_数组求和_直接寻址实现.png)

​		随着 N 的增大，程序的指令条数会越来越多，占据的存储空间也越来越大。

​		而如果使用变址寻址，只需要将数组元素的索引下标放入变址寄存器中，每次改变变址寄存器的内容（加 1），就能用同样的指令 “ ADD X, D ” 处理所有所有数的相加了。

![](E:\source\jk-english\英语语法初级\图片\4_25_数组求和_变址寻址实现.png)

​		利用一个条件转移指令（BNE），当变址寄存器 X 中内容还没有增大到 N 时，就跳转回 M 处再次执行相同的指令；当增大到 N 时就结束，得到最后结果。这样，不论 N 取多大，这段程序都只需用 7 条指令，所占存储单元大大减少。这其实就是 “循环” 的实现思路。

- 优点：可扩大寻址范围；在循环体中将 A 设为数组初始地址，可实现数组功能；适合编制循环程序。

##### 9. 相对寻址

​		**相对寻址** 也是偏移寻址的一种，它所基于的是 **程序计数器 PC** 。将 PC 的内容加上指令中的形式地址，就形成操作数的有效地址，即
$$
EA = (PC) + A
$$
​		相对寻址通常用于转移类指令，转移后的的目标地址与当前指令有一段距离，称为 **相对位移量**；这里就是形式地址 A ，所以 A 也称为 **位移量**。A 的位数决定了操作数的寻址范围，可正可负，用补码表示。

![](E:\source\jk-english\英语语法初级\图片\4_26_相对寻址.png)

​		相对寻址的最大特点是转移的目标地址不固定，可以随 PC 的值变化；这样，无论程序加载到主存的哪段区域，都以正确运行，对于编写浮动程序非常有利。例如，之前计算数据和的程序，跳转的目标地址固定为 M；如果程序的首地址发生了改变，M 也会变化。可以将条件转移指令改为相对寻址：

![](E:\source\jk-english\英语语法初级\图片\4_27_相对寻址案例.png)

​		这样，无论程序浮动到哪一地址空间，都可以正常运行了。另外，相对寻址也可以和间接寻址结合使用。

- 优点：便于程序浮动，广泛应用于转移指令。

##### 10. 堆栈寻址

​		**堆栈寻址** 要求计算机中设有堆栈。堆栈既可以用寄存器组来实现，称为 **硬堆栈**；也可以利用主存的一部分空间作为堆栈，称为 **软堆栈**。

​		以软堆栈为例，可以用一个 **堆栈指针 SP** （Stack Pointer）指出栈顶地址，也可以用 CPU 中的寄存器作为 SP。根据栈数据结构的特点，操作数只能在栈顶指针指向的存储单元里存取。

![](E:\source\jk-english\英语语法初级\图片\4_28_堆栈寻址PUSH.png)

![](E:\source\jk-english\英语语法初级\图片\4_29_堆栈寻址POP.png)

​		可以看出，堆栈寻址也是一种 **隐含寻址**，操作数的地址被隐含在了 SP 中。而从本质上看，把 SP 看作存放有效地址的寄存器，堆栈寻址就是一种 **寄存器间接寻址**。

​		堆栈有 **进栈（PUSH）**和 **出栈（POP）**两种操作：

- 进栈（PUSH A）：（SP）- 1 → SP；（ACC）→ M [ (SP) ]
- 出栈（POP A）： （M [ (SP) ]）→ ACC；（SP）+ 1 → SP

​		上面讨论的，都是主存按字编址的情况。如果主存按字节编址，则每次进出栈时 SP 的变化 Δ 会受到存储字长的影响；如果存储字长为 2 字节（16 位）则 Δ = 2，为 4 字节则 Δ = 4。

----

​		下表列出了所有寻址方式、有效地址及访存次数的简单总结（不含取本条指令的访存）。

|    寻址方式    |                   有效地址 EA                   |         访存次数          |
| :------------: | :---------------------------------------------: | :-----------------------: |
|    立即寻址    |                     不需要                      |             0             |
|    直接寻址    |                     EA = A                      |             1             |
|    间接寻址    |                    EA = (A)                     |       2（一次间址）       |
|    隐含寻址    |                 隐含在寄存器中                  |             0             |
|   寄存器寻址   |               EA = R<sub>i</sub>                |             0             |
| 寄存器间接寻址 |              EA = (R<sub>i</sub>)               |             1             |
|    基址寻址    |                  EA = (BR) + A                  |             1             |
|    变址寻址    |                  EA = (IX) + A                  |             1             |
|    相对寻址    |                  EA = (PC) + A                  |             1             |
|    堆栈寻址    | EA = (SP) - 1  （入栈） 或  EA = (SP)  （出栈） | 0（硬堆栈）或 1（软堆栈） |



### 4.4 CISC 和 RISC 的基本概念

​		指令集的不同会导致一个处理器的基础结构不同。

​		最早的 CPU 出现在 20 世纪 70 年代，当时的集成电路技术制约了一块芯片上能实现什么，所以它们的指令集都非常有限；以 8 位 CPU 为主，Intel 8080、MOS 6502、MC 6800 就是其中的代表。之后随着超大规模集成电路技术的发展，微处理器发展得非常迅速，指令集也越来越复杂；并且出现了将处理器、RAM、ROM 和 I/O接口等计算机基本部件集成到一个芯片上的微控制器（MCU），这就是 **单片机**，Intel 的 MCS-51 系列就是其中的代表。

​			<img src="C:/Users/18133/Desktop/课件/pictures/4_30_MOS 6502.png" style="zoom: 50%;" />		<img src="C:/Users/18133/Desktop/课件/pictures/4_31_红白机.png" style="zoom:50%;" />

​		<img src="C:/Users/18133/Desktop/课件/pictures/4_33_Intel 8080.png" style="zoom:45%;" />	<img src="C:/Users/18133/Desktop/课件/pictures/4_34_51单片机.png" style="zoom: 70%;" />

​		现代计算机按照处理器的 **指令集架构**（Instruction Set Architecture，**ISA**）主要可以分为两种：

- CISC（Complex Instruction Set Computer，复杂指令集计算机）
- RISC（Reduced Instruction Set Computer，精简指令集计算机）		

​		面对越来越多的需求，计算机需要完成的任务越来越重，对计算机性能的要求也越来越高。关于如何提升计算机性能，两种指令集架构代表了不同的思路。

#### 4.4.1 CISC

​		CISC 通过设置更多、更复杂的指令来实现更多的功能，这样就可以减少运行程序所需的指令数，依靠硬件提升运行速度。

​		这种架构的代表公司就是 Intel，它在 1978 年推出了著名的 16 位微处理器 8086，此后又推出了 80286 和 32 位的 80386、80486 以及 奔腾（Pentium）处理器，因而这一系列的处理器都被称为 “ **x86 架构** ”。如今已经进入 64 位时代，这一家族采用的指令集架构称为 “ x86-64 ” 或简称 “ x64 ”，代表就是酷睿（Core）处理器。AMD 公司生产的 CPU 主要也是 x86/64 架构。

​						<img src="C:/Users/18133/Desktop/课件/pictures/4_35_奔腾4.png" style="zoom:50%;" />					<img src="C:/Users/18133/Desktop/课件/pictures/4_36_酷睿.png" style="zoom:80%;" />

​		CISC 的主要特点如下：

- 指令数目庞大且复杂。Intel 描述全套指令的文档有 1200 多页；
- 指令字长是可变的。x86-64 的指令长度可以是 1 ~ 15 个字节；
- 每个指令可以执行若干简单操作，例如存储器读取、存储、计算操作等，因此很多指令都能进行访存操作，可以对内存中的操作数直接进行算术和逻辑运算；
- 寻址方式丰富。内存中操作数的指示符可以有各种组合，包括偏移量、基址和变址寄存器以及伸缩因子；
- 逻辑控制电路复杂，寄存器较少，使用主存中的软堆栈来实现堆栈寻址；
- 对机器级程序来说，实现细节是不可见的，全部由硬件完成。

​		因此，CISC 有着非常明显的优缺点。

- 优点：

  - 运行程序所需的指令数少，有效提升性能；

  - 更加依赖硬件实现功能，编写软件代码较为简单。

- 缺点：
  - 指令执行时间差异很大，复杂的指令需要若干时钟周期才可以实现；

  - 指令的使用频率差异很大，很多复杂指令的使用率并不高；

  - 有些指令非常复杂，以至于无法通过组合逻辑电路直接完成，所以需要采用 **微程序控制**；
  - 编译器能做的优化有限。  

#### 4.4.2 RISC

​		庞大的指令系统设计起来非常复杂，研制周期变得很长，成本耗费巨大。而且对传统 CISC 的测试发现，典型程序中 80% 的语句只用到了系统中 20% 的指令，这被称为 80 - 20 规律。

​									<img src="C:/Users/18133/Desktop/课件/pictures/4_30_二八定律.png" style="zoom:80%;" /> 

​		于是人们开始了对指令系统合理性的研究，试图通过 “做减法” 来从另一个角度提升效率，这样就产生了 RISC。 

​		RISC 的主要思路是减少指令种类、简化指令功能，通过降低单个指令的执行周期数（CPI）来提高 MIPS，从而提升运行速度。

​		由于简化了指令集，CPU 芯片就不需要太大的空间来制作逻辑控制电路，而可以加入更多的寄存器，这样就可以让数据运算更快。基于这样的想法，IBM 公司开发出了第一代 RISC 架构计算机；与此同时，斯坦福大学的 RISC 研究课题 MIPS，考虑到了对处理器流水线的优化，研究结果转化成了后来 MIPS 公司的 R 系列产品。

​		1985 年，Acom 公司设计出了基于 RISC 指令集的 32 位计算机，简称 ARM（Acorn RISC Machine）。1990 年，Acom 改组为 ARM 公司，专门研发芯片架构、出售芯片技术授权，它的指令集架构就被称为 “ **ARM 架构** ”。由于 ARM 架构低功耗、低成本的特点，在嵌入式处理器中得到了非常广泛的应用：智能手机、智能汽车、智能家居等各种领域都可以看到 ARM 架构处理器的身影。

​			<img src="C:/Users/18133/Desktop/课件/pictures/4_37_苹果A17.png" style="zoom:50%;" />				<img src="C:/Users/18133/Desktop/课件/pictures/4_38_高通骁龙8gen1.png" style="zoom:45%;" />				<img src="C:/Users/18133/Desktop/课件/pictures/4_39_麒麟9000s.png" style="zoom:50%;" />

​		如今 RISC 架构已经发展到第五代，称为 **RISC-V**，这是一个完全开源的指令集架构，采用宽松的 BSD 协议，企业可以完全自由免费使用，同时也容许企业添加自有指令集进行拓展。

​		RISC 的主要特点有:  

- 指令数量比 CISC 要少得多；只使用频度较高的简单指令，通过简单指令的组合实现复杂指令功能。早期的 RISC 指令通常少于 100 个；

- 指令字长是固定的。早期的 RISC 通常将所有的指令都编码为 4 个字节；

- 允许访存的指令只有 load 和 store，这被称为 **load / store 体系结构**。因此只能对寄存器中的操作数进行算术和逻辑运算，不能直接对内存中的操作数进行运算；

- 寻址方式简单，一般所有的 load / store 都通过寄存器中的内容和指令字段中的偏移量来实现；

- 逻辑控制电路比较简单，有大量的通用寄存器，可以使用硬堆栈来实现堆栈寻址。

- 对机器级程序来说，实现细节是可见的。因此编译器需要在一些约束条件下进行性能优化；

  因此，RISC 的优缺点和 CISC 相比也是非常明显的。

- 优点：

  - CPI 大大降低，并且通过大量寄存器减少了访存次数，有效提升性能；
  - 采用流水线技术，大部分指令在一个时钟周期完成；采用超标量和超流水线技术，可以使每条指令的平均执行时间小于一个时钟周期；
  - 控制器便于设计和实现，采用组合逻辑控制（硬布线），不用微程序控制；

  - 可以利用编译器对程序性能进行优化。
  - 低功耗、低成本

- 缺点：

  - 指令的种类和寻址方式都比较少，编写软件比较麻烦；有些早期的 RISC 机器甚至没有乘法指令，需要用一系列加法来实现；
  - 对编译器的要求比较高，编译器采用不同的优化策略可以显著改变运行性能；

  - 不同指令系统间兼容性差。

#### 4.4.3 CISC 和 RISC 的比较

​		下表中详细列出了 CISC 和 RISC 的特点对比：

|      对比项目      |          CISC          |             RISC             |
| :----------------: | :--------------------: | :--------------------------: |
|      指令数量      |           多           |             较少             |
|      指令字长      |         不固定         |             固定             |
|     可访存指令     |         无限制         |         Load / Store         |
|  各种指令使用频率  |        相差很大        |           相差不大           |
|  各种指令执行时间  |        相差较大        | 绝大多数在一个时钟周期内完成 |
|      寻址方式      |           多           |              少              |
|   通用寄存器数量   |          较少          |              多              |
|      堆栈寻址      |         软堆栈         |            硬堆栈            |
|      控制方式      |       微程序控制       |    组合逻辑控制（硬布线）    |
| 机器级程序实现细节 |         不可见         |             可见             |
|       编译器       |        难以优化        |           需要优化           |
|     指令流水线     | 可以通过一定的方式实现 |           必须实现           |
|        功耗        |          较高          |             较低             |
|       兼容性       |          较好          |             较差             |
|    主要应用领域    |      PC 和服务器       |          嵌入式设备          |

​		如今，RISC 机器在发展进化的过程中，逐渐引入了更多的指令；而 CISC 机器也会充分利用高性能的流水线结构。商品化的计算机一般都会将 RISC 和 CISC 结合起来，取长补短。

### 4.5 高级语言程序与机器级代码

#### 4.5.1 x86 汇编指令基础

##### 1. 相关寄存器

**（1）通用寄存器**

​		x86 架构的 CPU 中会设置一组 **通用寄存器**，用来存储整数数据和指针（地址）。

​		最初的 8086 有 8 个 16 位的寄存器，分别叫做 ax、bx、cx、dx、si、di、bp、sp，每个寄存器都有各自特殊的用途，这都体现在它们的名字中。当扩展到 32 位架构（标准名称为 IA32）时，这些寄存器也都扩展为 32 位，名称前加上了 ’‘e“ 表示扩展（extended）。

​		每个 32 位的通用寄存器，都可以将低 16 位当作一个 16 位寄存器独立使用，最低 8 位当作一个 8 位寄存器使用；而 ax、bx、cx、dx 的高低字节都可以分别作为两个 8 位寄存器，称为 ah、bh、ch、dh 和 al、bl、cl、dl。

![](E:\source\jk-english\英语语法初级\图片\4_40_IA32寄存器.png)

​		这里用途最为特殊的，就是堆栈指针 ebp 和 esp，它们配合可以很容易地实现子过程的调用和返回；另外，一般也经常用 **ebp + 偏移量** 的形式来定位存放在栈中的局部变量。

​		扩展为 64 位的 x86-64 架构后，原先的 8 个 32 位寄存器全部扩展到 64 位，标号以 r 开头；此外还新增了 8 个通用寄存器，标号为 r8 ~ r15。

​                        <img src="C:/Users/18133/Desktop/课件/pictures/4_41_x64寄存器-1.png" style="zoom: 75%;" /> 

​                        <img src="C:/Users/18133/Desktop/课件/pictures/4_41_x64寄存器-2.png" style="zoom:75%;" /> 

**（2）指令指针寄存器**

​		除通用寄存器外，x86 架构的 CPU 还会设置一系列特殊功能的寄存器。其中最为重要的就是 **指令指针寄存器 IP**（Instruction Pointer），它存放了下一条要执行的指令的地址；很明显，这其实就是我们之前介绍的 **程序计数器 PC**。

​		最初的 ip 也是 16 位的；到了 IA32 架构下，指令指针寄存器也扩展为 32 位，称为 eip；而到了 x86-64 时代，对应也扩展成了 64 位的指令寄存器，称为 rip。

**（3）标志寄存器**

​		**标志寄存器 flags ** 里面有众多标志位，记录了 CPU 执行指令过程中的一系列状态，大都由 CPU 自动设置和修改。

- ZF 零标志
- CF 进位标志
- SF 符号标志
- OF 溢出标志
- PF 奇偶标志
- TF 跟踪标志
- IF 中断标志
- ...

​		很显然，标志寄存器其实就是之前提到的 **程序状态字 PSW**。IA32 架构下标志寄存器为 32 位，称为 **efl（eflags）**，除去一些不使用的保留位外，每一位都对应着一个状态标志；x86-64 架构下扩展为 64 位，不过扩展的高位都没有使用，相当于还是 32 位。

##### 2. 汇编指令格式

​		对于 x86 指令集的汇编代码，也有两种不同的指令格式。

- ATT 格式：由 AT&T 公司而得名，这是 GCC 等常用工具的默认格式。
- Intel 格式：Intel 文档中和 Microsoft 编程工具采用的汇编格式。

​		这两种格式整体风格相似，但也有很多不同：

![](E:\source\jk-english\英语语法初级\图片\4_42_ATT vs Intel格式.png)

​		x86 是复杂指令集架构，支持多种寻址方式，两种格式的各种寻址方式如下：

![](E:\source\jk-english\英语语法初级\图片\4_43_ATT vs Intel寻址方式.png)

​		下面是 mov 指令的一些示例。mov 指令用于移动数据，可以将立即数、寄存器和内存中的操作数，移动到寄存器或者内存中。需要注意，ATT 格式的数据传输方向是从左向右，而 Intel 格式恰好相反。

![](E:\source\jk-english\英语语法初级\图片\4_45_ATT vs Intel mov 指令.png)

​		mov 指令不能将一个内存中的操作数，移动到另一个内存地址。

​		下面我们主要以 Intel 格式为例，来详细介绍 C 语言和汇编指令的对应关系。

##### 3. 常用汇编指令

**（1）数据传输指令**

- mov：在寄存器和内存之间移动数据；
- lea：load effective address，加载有效地址，将一个内存地址加载到目的寄存器；
- push：将数据压入栈，同时 esp 减去数据长度；
- pop：将栈顶数据弹出栈，同时 esp 加上数据长度；

**（2）算术和逻辑运算指令**

​		主要可以按照操作数的个数分为两类：

- 双操作数 —— add（加）、sub（减）、mul（无符号乘）、imul（有符号乘）、and（逻辑与）、or（或）、xor（异或）、sal/shl（左移）、sar（算术右移）、shl（逻辑右移）

​		格式为：  op  D, S

​		表示计算 D (op) S 的值，结果存入 D 中。

- 单操作数 ——  inc（自增）、dec（自减）、neg（取负）、not（取反）

​		计算的结果仍然存入操作数所在位置。

![](E:\source\jk-english\英语语法初级\图片\4_46_算术和逻辑指令.png)

​		比较特别的是除法指令，它们都只有一个操作数，表示除数，被除数则放在 edx : eax 中；得到的结果商放在 eax 中，余数放在 edx 中：

- div：无符号除
- idiv：有符号除

**（3）转移指令**

- **无条件转移：jmp**

​		jmp 指令后面一般跟一个 “标签”（label），用来指明可以直接跳转到的目的地。它的底层编码一般都是 **PC 相对的**，也就是相对寻址。

- **有条件转移**

​		标志寄存器 efl 中有很多标志状态，也称为 “**条件码**”，它们记录了最近的算术逻辑操作的结果属性。通过检测这些寄存器中的条件码，就可以执行条件转移指令了。最常用的条件码有：ZF（零标志）、CF（进位标志）、SF（符号标志）、OF（溢出标志）；一般会对它们进行组合，用来表示更加容易理解的控制条件。

![](E:\source\jk-english\英语语法初级\图片\4_47_常用转移指令.png)

​		上面的条件跳转指令，需要先做一个算术或逻辑运算、更改条件码；而很多时候我们只需要做一个简单比较即可，并不需要将运算结果保存。有两类特殊指令可以只改变条件码、而不改变其它任何的寄存器：

![](E:\source\jk-english\英语语法初级\图片\4_48_比较和测试指令.png)

​		这两种指令，特别是 cmp 经常和条件转移指令配合使用，用来实现条件分支（选择）和循环结构的程序。

- 调用和返回

  进行子过程（函数）调用时，使用 call 指令；返回原函数时使用 ret 指令。

#### 4.5.2 从 C 语言程序到汇编程序

##### 1.  编译器、汇编器和链接器

​		用高级语言编写好一段程序之后，需要经过一系列“翻译“过程，才能得到计算机能够执行的机器代码。比如，我们用 C 语言写了一个简单的 hello world 程序，源程序文件命名为 hello.c，用 GCC 编译器可以将它翻译成一个可执行目标程序 hello。具体的过程如下图所示：

![](E:\source\jk-english\英语语法初级\图片\1_7_源程序转换为可执行程序的过程-1723988340725.png)

​		第二步编译的结果，生成了汇编程序 hello.s，这就是汇编语言描述的机器指令；汇编程序再经过汇编就可以得到二进制的机器语言程序。

​		在一些集成开发环境（比如 Visual Studio）中，可以在调试（Debug）模式下对机器码进行 ”反汇编“，得到相应的汇编语言代码。

##### 2. 进程的地址空间

​		C 语言程序运行之后，对应的进程都会有自己独立的地址空间；这就是操作系统为每个进程提供的 虚拟地址空间。对于 32 位系统，进程虚拟地址空间的大小就是 2^32^ B = 4 GB。

​		整个虚拟空间需要操作系统统一管理，因此进程的虚拟地址空间中必须保留一部分给操作系统内核使用。对于 Linux 系统（32 位），内核区大小为 1GB，地址从 0xc0000000 ~ 0xffffffff；而 Windows 系统默认情况下内核区大小为 2GB，地址从 0x80000000 ~ 0xffffffff。其余低地址部分则为用户区。

​		下面是一个 x86 Linux 进程的虚拟地址空间。

![](E:\source\jk-english\英语语法初级\图片\4_53_进程的内存映像.png)

​		用户区主要包括这样几部分：

- 程序代码和数据：主要包括 **只读代码段** 和 **读写段**（.data 和 .bss）。对所有进程来说，代码都是从固定地址开始，紧接着就是 C 语言中的全局和静态数据。其中 .data 中是已初始化的全局和静态 C 变量，而 .bss 中是未初始化的全局和静态变量。
- 堆（Heap）：用于运行时的动态内存分配，向上（高地址）生长。代码和数据区，在进程开始运行时就被指定了大小；而通过调用 malloc 和 free 这样的 C 标准库函数，可以让堆区动态地扩展和收缩。
- 共享库的内存映射区：用户区的中间部分是一块内存映射区域，用来存放像 C 标准库这样的共享库。
- 用户栈（Stack）：位于虚拟地址空间用户区顶部，向下（低地址）生长。一般用来存储局部变量和函数参数，结合堆栈指针可以方便地实现函数的调用和返回。

##### 3. 利用栈实现函数调用

​		C 语言中的函数是一种重要的抽象，它将代码按功能封装起来，让程序结构更加清晰、可重用性更高。

​		每个函数内部可以定义局部变量，这些变量只具有局部作用域。所以，嵌套函数调用时（例如，在函数 P 中调用函数 Q），就可以利用栈数据结构 ” 后进先出 “（LIFO）的特点，在栈内依次保存函数 P 和 Q 的相关内容。

​		这样，进程中的每一个函数，都会在栈上有一块自己的空间，就叫做 ” **栈帧** “（stack frame）；当前正在执行的函数的栈帧总是在栈顶。这样 esp 的内容就是栈顶地址，而 ebp 的内容就保存当前栈顶栈帧的 “底部” 地址。

​										![](E:\source\jk-english\英语语法初级\图片\4_54_栈帧.png)

​		于是，在调用一个函数 Q（子过程）时，可以在栈上继续给 Q 中的局部变量分配内存空间（入栈）。当 Q 调用结束，就将 Q 的所有局部变量释放（出栈）。

​		想要用机器级代码实现函数调用，还需要考虑下面几个问题：

​		① 参数传递：函数 Q 应该能获取到 P 传入的参数；这可以通过指定参数存放的位置（写入寄存器或者入栈）来实现。

![](E:\source\jk-english\英语语法初级\图片\4_55_参数构造.png)

​		② 转移控制：调用 Q 时，需要跳转到函数 Q 入口处执行指令，这可以用 call 指令实现；调用结束，还应返回到 P 中的调用点继续执行，这需要保存之前调用点的信息，将下一条指令地址入栈。

![](E:\source\jk-english\英语语法初级\图片\4_56_返回地址_1.png)

​		等到调用结束时，执行 ret 指令返回，就执行出栈操作，将栈中保存的地址交给 eip，继续执行 P 中的下一条指令。

![](E:\source\jk-english\英语语法初级\图片\4_57_返回地址_2.png)

​		③ 保存上下文：原函数 P 使用的寄存器的内容，应该进行保存；调用结束后，还应该进行恢复。

​		调用 Q 后，可以先将原函数 P 的上下文（寄存器值）做一个入栈保存；然后再分配内存给 Q 的局部变量。待 Q 调用结束后，先释放 Q 的局部变量，然后继续弹栈恢复 P 的上下文。

![](E:\source\jk-english\英语语法初级\图片\4_58_保存上下文.png)

​		比较特殊的是栈基指针 ebp，在调用 Q 之后，它应该指向 Q 的栈帧的底部；所以应该先将之前的 ebp（P 的栈帧底部）入栈，然后将 ebp 移向 esp 的位置。之后再保存 P 其它寄存器的值、分配空间给 Q 的局部变量。

```
push  ebp
mov   ebp, esp
```

​		当 Q 调用结束返回时，只要反向执行，让 esp 移向 ebp 的位置；再将原先保存的 ebp 的值弹出，并放入 ebp 中就可以了：

```
mov   esp, ebp
pop   ebp
```

​		对于函数调用开始时（call 之后）两条对 ebp 的处理指令，可以用一条 enter 指令来代替；函数结束时（ret 之前）的两条指令，则可以用 leave 来代替。

​		④ 返回值传递：函数 Q 调用结束，执行 ret 指令，此时应该能将返回值传回原函数 P；可以通过指定某个寄存器（eax）接收返回值来实现。

​		这样，我们可以将完整的栈帧结果表示如下：

​							![](E:\source\jk-english\英语语法初级\图片\4_59_栈帧结构.png)

​		栈帧中主要由 4 部分构成：上一层函数的上下文（主要是寄存器的值）、当前函数的局部变量、调用下一层函数所需的参数，以及返回地址。对于当前执行的函数 Q，没有参数构造区和返回地址两部分。

#### 4.5.3 选择结构语句的机器级表示

​		除顺序结构外，高级语言程序中一般还会有选择结构和循环结构。

​		**选择结构** 又称为 **分支（branch）结构**。C 语言中的选择语句主要有 if ... else 和 switch ... case，此外三目运算符 ? : 也可以实现选择结构。

​		很显然，通过设置条件码（标志位）、结合各类转移指令，就可以很容易地实现程序中的选择语句。

​		下面一段 C 语言代码使用 if - else 语句实现了选择结构：

```C
int a = 23;
int b = 31;
if (a > b)
{
	a++;
}
else {
	a--;
}
printf(" a = %d\n", a);
```

​		可以发现它等效于使用 2 个 goto，分别跳过 if 后面的分支和 else 后面的分支：

```C
	if (a <= b)
		goto L1;
	a++;
	goto L2;
L1:
	a--;
L2:
	printf(" a = %d\n", a);
```

​		这样，很容易得到对应的汇编代码：

![](E:\source\jk-english\英语语法初级\图片\4_49_选择结构的汇编表示.png)

#### 4.5.4 循环结构语句的机器级表示

​		C 语言中的循环语句有 do - while、while 和 for 三种。汇编语言中，同样可以用条件测试和跳转指令的组合来实现循环的效果。在循环结构中，通常使用条件转移指令来判断循环的结束。

##### 1. do - while 循环

​		下面是一段使用了 do - while 循环的 C 语言代码：

```C
int a = 0;
do {
	a++;
} while (a < 5);
printf(" a = %d \n ", a);
```

​		很明显，循环部分可以利用 if 判断和 goto 语言来实现：

```C
	int a = 0;
L1:
	a++;
	if (a < 5)
		goto L1;
	printf(" a = %d \n ", a);
```

​		这样，类比之前选择结构，可以得到对应的汇编表示如下：

![](E:\source\jk-english\英语语法初级\图片\4_50_do-while的汇编表示.png)

##### 2. while 循环

​		while 循环与 do - while 类似，区别在于第一次执行循环体之前就要先做条件判断。下面是一段 while 循环的 C 语言代码：

```C
int a = 0;
while (a < 5) {
	a++;
}
printf(" a = %d \n ", a);
```

​		如果用 goto 进行改写，可以参考 if - else 的实现，使用两个 goto 分别进行满足、不满足循环条件时的跳转：

```C
	int a = 0;
L1:
	if (a >= 5)
		goto L2;
	a++;
	goto L1;
L2:
	printf(" a = %d \n ", a);
```

​		于是对应的汇编程序如下：

![](E:\source\jk-english\英语语法初级\图片\4_51_while的汇编表示.png)

##### 3. for 循环

​		for 循环可以将循环变量和循环条件统一列出，因此对程序员来说是最友好的；但它直接转换成汇编语言会有一定的难度。for 循环的基本形式如下：

```C
for( 初始化循环变量; 判断循环条件; 更新循环变量)
    循环体
```

​		可以把它先改写成 while 循环的形式：

```C
初始化循环变量;
while( 判断循环条件 )
{
    循环体;
    更新循环变量;
}
```

​		这样，就可以用 goto 改写如下：

```C
	初始化循环变量;
L1:
	if（循环条件不成立）
    	goto L2;
    循环体;
    更新循环变量;
	goto L1;
L2:
	循环外语句;
```

​		当然，如果不改写成 while、完全按照 for 循环的执行顺序来处理，就会麻烦很多。比如下面是一段 for 循环的 C 语言代码：

```C
int a = 10;
for (int i = 0; i < 5; i++)
{
	a--;
}
printf(" a = %d \n ", a);
```

​		对应的汇编代码如下：

![](E:\source\jk-english\英语语法初级\图片\4_52_for的汇编表示.png)

​		很明显，本质上三种循环都是等效的，而比较之下 do-while 循环的汇编指令最简洁。因此，大多数编译器会进行优化，将另两种循环语句转换为 do-while 语句形式来生成机器代码。

​		另外，x86 架构指令集还提供了一个 loop 指令专门用于循环的实现。它默认使用 ecx 寄存器作为循环计数器，每次执行到 loop 指令都会先对 ecx 做减 1 操作；然后判断 ecx 是否为 0，如果不为 0 则跳转到 loop 后面标号对应的位置，如果为 0 则循环结束继续向下执行。

```
mov ecx, 10
.L1:
mov eax, dword ptr [a]
sub eax, 1
mov dword ptr [a], eax
loop .L1
```

​		上面的 loop 指令相当于：

```
dec ecx
cmp ecx, 0
jne .L1
```

​		这样减少了指令数，汇编代码的可读性更高了。除 loop 外，还有类似的 loopz 和 loopnz 指令，它们判断循环继续的条件除了 ecx != 0 外，还有对 ZF 的要求。

#### 4.5.5 过程（函数）调用对应的机器级表示

​		下面是一段 C 语言的函数调用过程。我们在 main 函数中调用了 add 函数，进行两个整数的求和。

```C
int add(int x, int y);

int main() {
	int a = 23;
	int b = 31;

	int sum = add(a, b);

	printf(" sum = %d\n", sum);
}

int add(int x, int y) {
	int sum = x + y;
	return sum;
}
```

​		函数调用时，首先应该跳转之前，将需要的参数进行保存；然后执行 call 指令，同时将下一条指令地址入栈。主程序 main 对应的汇编代码如下：

![4_60_过程调用_主程序](E:\source\jk-english\英语语法初级\图片\4_60_过程调用_主程序.png)

​		调用函数 add 后，首先应该将原来的 ebp 入栈，并将 ebp 指向当前 esp 的位置（add 函数栈帧的底部）；然后保存之前其它寄存器的值（入栈）。之后分配局部变量的空间，执行 add 内部指令。执行完毕后，做反向操作，弹栈恢复所有寄存器的值，返回 main 函数的调用处继续执行。

​		add 函数对应的汇编指令如下：

![](E:\source\jk-english\英语语法初级\图片\4_61_过程调用_子程序.png)

### 4.6 章节练习

#### 一、单项选择题

1. 【2010真题】下列寄存器中，汇编语言程序员可见的是	（    ） 
   A．存储器地址寄存器（MAR） B．程序计数器（PC）
   C．存储器数据寄存器（MDR） D．指令寄存器（IR）

​		答案：B

2. 【2021真题】下列寄存器中，汇编语言程序员可见的是	（    ）

​		Ⅰ.指令寄存器				Ⅱ.微指令寄存器				Ⅲ.基址寄存器				Ⅳ.标志/状态寄存器

​		A.仅Ⅰ、Ⅱ						B.仅Ⅰ、Ⅳ						C.仅Ⅱ、Ⅳ						D.仅Ⅲ、Ⅳ

​		答案：D

​		要点：汇编程序员可见的寄存器有基址寄存器、变址寄存器、状态/标志寄存器（PSW）、程序计数器 PC 和通用寄存器组；而 MAR、MDR、IR 是 CPU 内部工作寄存器， 对汇编程序员不可见。微指令寄存器属于微程序控制器的组成部分， 它是硬件设计者的任务，对汇编程序员是透明的。

3. 【2022真题】下列选项中，属于指令集体系结构（ISA）规定的内容是 	（    ）

​		I. 指令字格式和指令类型 		II. CPU 的时钟周期 		III. 通用寄存器个数和位数 		IV. 加法器的进位方式 

​		A. 仅 I、 II 						B. 仅I、 III 					C. 仅 II、 IV 					D. 仅 I、 III、 IV 

​		答案：B

​		要点：指令集处于软硬件的交界面上。指令字和指令格式、通用寄存器个数和位数都与机器指令有关，由 ISA 规定。两个 CPU 可以有不同的时钟周期，但指令集可以相同，CPU 的时钟周期不由 ISA 规定。 加法器的进位方式涉及电路设计， 也不由指令集规定。

4. 【2009真题】下列关于 RISC 的叙述中， 错误的是 	（    ）
   A． RISC 普遍采用微程序控制器
   B． RISC 大多数指令在一个时钟周期内完成
   C． RISC 的内部通用寄存器数量相对 CISC 多
   D． RISC 的指令数、寻址方式和指令格式种类相对 CISC 少 

​		答案：A

​		要点：相对于 CISC ， RISC 的特点是以硬布线逻辑为主，不用或者少用微程序控制。

5. 【2011真题】下列给出的指令系统特点中，有利于实现指令流水线的是 	（    ）

​		Ⅰ ．指令格式规整且长度一致 

​		Ⅱ ．指令和数据按边界对齐存放 

​		Ⅲ．只有 Load/Store 指令才能对操作数进行存储访问 

​		A．仅Ⅰ 、 Ⅱ	 				B．仅Ⅱ 、 Ⅲ 					C．仅Ⅰ 、 Ⅲ 					D． Ⅰ 、 Ⅱ 、 Ⅲ 

​		答案：D

​		要点：以上三点都是 RISC 的特点，都可以有效简化指令流水线的复杂度。

6. 【2016真题】某计算机主存空间为 4GB，字长为 32 位，按字节编址，采用 32 位字长指令字格式。若指令按字边界对齐存放，则程序计数器（PC）和指令寄存器（IR）的位数至少分别是 	（    ）

​		A． 30、 30 	B． 30、 32 	C． 32、 30 	D． 32、 32 

​		答案：B

​		要点：程序计数器（PC）给出下一条指令字的访存地址，取决于存储器的字数；指令寄存器（IR）用于存放取得的指令，取决于指令字长。

7. 【2017真题】某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令 29 条，二
   地址指令 107 条，每个地址字段为 6 位，则指令字长至少应该是	（    ）

​		A． 24位 	B． 26位 	C． 28位	 D． 32位 

​		答案：A

​		要点：指令字长应是字节的整数倍。

8. 【2022真题】设计某指令系统时，假设采用 16 位定长指令字格式，操作码使用扩展编码方式，地址码为 6位，包含零地址、 一地址和二地址 3 种格式的指令。 若二地址指令有 12 条，一地址指令有254 条，则零地址指令的条数最多为 	（    ）

​		A. 0 	B. 2 	C. 64 	D. 128 

​		答案：D

9. 【2011真题】偏移寻址通过将某个寄存器内容与一个形式地址相加而生成有效地址。下列寻址方式中， 不属于偏移寻址方式的是	（    ）

​		A．间接寻址   B．基址寻址   C．相对寻址   D．变址寻址

​		答案：A

10. 【2017真题】下列寻址方式中，最适合按下标顺序访问一维数组元素的是	（    ）

​		A．相对寻址	 B．寄存器寻址 	C．直接寻址 	D．变址寻址

​		答案：D

11. 【2020真题】某计算机采用 16 位定长指令字格式，操作码位数和寻址方式位数固定，指令系统有 48 条指令，支持直接、间接、立即、相对 4 种寻址方式。单地址指令中，直接寻址方式的可寻址范围是	（    ）

​		A. 0 ~ 255				B. 0 ~ 1023				C. -128 ~ 127				D. -512 ~ 511

​		答案：A

​		要点：4 种寻址方式需要有 2 位寻址特征位。

12. 【2009真题】某机器字长为 16 位，主存按字节编址，转移指令采用相对寻址，由两个字节组成，
    第一字节为操作码字段，第二字节为相对位移量字段。假定取指令时，每取一个字节 PC 自动加 1。若某转移指令所在主存地址为 2000H，相对位移量字段的内容为 06H，则该转移指令成功转移后的目标地址是  （    ）

​		A． 2006H	 B． 2007H 	C． 2008H 	D． 2009H

​		答案：C

13. 【2013真题】假设变址寄存器 R 的内容为 1000H，指令中的形式地址为 2000H；地址 1000H 中的内容为 2000H，地址 2000H 中的内容为 3000H，地址 3000H中的内容为 4000H，则变址寻址方式下访问到的操作数是	（	）。

​		A.1000H						B.2000H						C.3000H						D.4000H

​		答案：D

14. 【2014真题】某计算机有 16 个通用寄存器，采用 32 位定长指令字， 操作码字段（含寻址方式位）为 8 位，Store 指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式。若基址寄存器可使用任一通用寄存器， 且偏移量用补码表示， 则 Store 指令中偏移量的取值范围是	（    ）

​		A. -32768-+32767 				B. -32767-+32768 				C. -65536-+65535 				D. -65535-+65536 

​		答案：A

​		要点：16 个寄存器需要 4 位地址码表示。

15. 【2016真题】某指令格式如下所示 

    ![](E:\source\jk-english\英语语法初级\图片\4_62_小题题图.png)

    其中 M 为寻址方式， I 为变址寄存器编号， D 为形式地址。若采用先变址后间址的寻址方式，则操作数的有效地址是 	（    ）

    A． I + D 	B． ( I ) + D  	C． ( ( I ) + D ) 	D． ( ( I ) ) + D 

    答案：C

    要点：变址寻址中 EA = ( I ) + D；间接寻址中 EA = （ D ）。

16. 【2018真题】按字节编址的计算机中，某 double 型数组 A 的首地址为 2000H，使用变址寻址和循环结构访问数组 A，保存数组下标的变址寄存器初值为 0，每次循环取一个数组元素，其偏移地址为变址值乘以 sizeof(double)，取完后变址寄存器内容自动加 1 。若某次循环所取元素的地址为 2100H，则进入该次循环时变址寄存器的内容是     （    ）。

​		A.25								B.32								C.64								D.100

​		答案：B

​		要点：数组首地址就是形式地址 D，变址寄存器中存放的是数组下标。

17. 【2018真题】减法指令“sub R1,R2,R3”的功能为“(R1)-(R2)→R3”，该指令执行后将生成进位/借位标志CF 和溢出标志 OF。若(R1)=FFFF FFFFH，(R2)=FFFF FFF0H，则该减法指令执行后，CF 与 OF 分别为	（    ）。

​		A. CF = 0, OF = 0					B. CF = 1 , OF = 0					C. CF = 0, OF = 1					D. CF = 1, OF = 1

​		答案：A

​		要点：减法操作只需判断借位标志；当最高位进位和符号位进位的值不相同时才产生溢出。

18. 【2019真题】某计算机采用大端方式，按字节编址。某指令中操作数的机器数为 1234 FF00H，该操
    作数采用基址寻址方式，形式地址（用补码表示）为 FF12H，基址寄存器的内容为 F000 0000H，
    则该操作数的 LSB（最低有效字节）所在的地址是 	（    ）

​		A． F000 FF12H 	B． F000 FF15H	 C． EFFF FF12H 	D． EFFF FF15H 

​		答案：D

​		要点：基址寻址方式， EA = (BR) + A；大端方式编址，低位字节存放在字的高地址处。

#### 二、综合应用题

1. 【2017真题】在按字节编址的计算机 M 上，上题中 f1 的部分源程序（阴影部分）与对应的机器级代码（包括指令的虚拟地址）如下：

```C
int f1(unsigned n){
	int sum=1, power=1;
	for(unsigned i=0;i<=n-1;i++){
		power *= 2;
		sum += power;
	}
	return sum;
} 
```

```
		int f1(unsigned n)
1		00401020	55				push ebp
		...			...				...
			for(unsigned i=0;i<=n-1;i++)
		...			...				...
20		0040105E	39 4D F4		cmp dword ptr [ebp-0Ch], ecx
		...			...				...
			{	power *= 2;
		...			...				...
23		00401066	D1 E2			shl edx, 1
		...			...				...
			return sum;
		...			...				...
35		0040107F	C3				ret
```

​		其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令。请回答下列问题。

​	（1）计算机 M 是 RISC 还是 CISC？ 为什么？ 

​	（2）f1 的机器指令代码共占多少字节？要求给出计算过程。

​	（3）第 20 条指令 cmp 通过 i 减 n-1 实现对 i 和 n-1 的比较。执行 f1(0) 过程中当 i=0 时， cmp 指令执行后，进/借位标志 CF 的内容是什么？要求给出计算过程。

​	（4）第 23 条指令 shl 通过左移操作实现了 power *2 运算，在 f2 中能否也用 shl 指令实现 power *2？ 为什么？ （注：将 f1 中的 int 都改为 float， 可得到计算 f(n) 的另一个函数 f2。）

​		**答案：**

​	（1）M 为 CISC。 因为 M 的指令长短不一，不符合 RISC 指令系统特点。

​	（2）f1 的机器代码占 96 B。

​		因为 f1 的第一条指令 “push ebp” 所在的虚拟地址为 0040 1020H，最后一条指令 “ret” 所在的虚拟地址为 0040 107FH，所以， f1 的机器指令代码长度为 0040 107FH - 0040 1020H + 1 = 60H = 96 个字节。  

​	（3）CF = 1。

​		cmp 指令实现 i 与 n-1 的比较功能，进行的是减法运算。在执行 f1(0) 过程中， n=0，当 i=0 时，i = 0000 0000H，n-1 = FFFF FFFFH。因此，当执行第 20 条指令时，在补码加/减运算器中执行 “0 减 FFFF FFFFH” 的操作，即 0000 0000H+0000 0000H+1=0000 0001H，此时，进位输出 C=0，减法运算时的借位标志 CF=C⊕1=1。 

​	（4）f2 中不能用 shl 指令实现 power\*2。

​		因为 shl 指令用来将一个整数的所有有效数位作为一个整体左移；而 f2 中的变量 power 是 float 型，其机器数中不包含最高有效数位，但包含了阶码部分，将其作为一个整体左移时并不能实现 “乘 2” 的功能，因而 f2 中不能用 shl 指令实现 power*2。

-----

2. 【2019真题】已知 $f(n) = n! = n*(n-1)*(n-2)*...*2*1$ ，计算 f(n) 的 C 语言函数 f1 的源程
   序（阴影部分）及其在 32 位计算机 M 上的部分机器级代码如下：  

   ![](E:\source\jk-english\英语语法初级\图片\4_63_大题题2图.png)

​		其中，机器级代码行包括行号、虚拟地址、机器指令和汇编指令，计算机 M 按字节编址， int 型数据占 32 位。请回答下列问题：

​	（1）计算 f(10) 需要调用函数 f1 多少次？执行哪条指令会递归调用 f1？

​	（2）上述代码中，哪条指令是条件转移指令？哪几条指令一定会使程序跳转执行？

​	（3）根据第 16 行的 call 指令，第 17 行指令的虚拟地址应是多少？已知第 16 行的 call 指令采用相对寻址方式，该指令中的偏移量应是多少（给出计算过程）？已知第 16 行的 call 指令的后 4 字节为偏移量， M 是采用大端方式还是采用小端方式？

​	（4） f(13) = 6227020800，但 f1(13) 的返回值为 1932053504，为什么两者不相等？要使 f1(13) 能返回正确的结果，应如何修改 f1 的源程序？

​	（5）第 19 行的 imul 指令（带符号整数乘）的功能是 R[eax]←R[eax]×R[ecx]，当乘法器输出的高、低 32 位乘积之间满足什么条件时，溢出标志 OF = 1？要使 CPU 在发生溢出时转异常处理，编译器应在 imul 指令后应加一条什么指令？ 

​		**答案：**

​	（1）计算 f(10) 需要调用函数 f1 共 10 次，执行第 16 行的 call 指令会递归调用 f1。
​	（2）第 12 行的 jle 指令是条件转移指令，其含义为小于等于时转移，本行代码的意义为：当 n≤1 时，跳转至地址 0040 1035H。

​		第 16 行的 call 指令为函数调用指令，第 20 行的 jmp 指令为无条件转移指令，第 30 行的 ret 指令为子程序的返回指令，这三条指令一定会使程序跳转执行。

​	（3）其长度计算机 M 上按字节编址，第 16 行的 call 指令的虚拟地址为 0040 1025H，长度为 5 字节，故第 17 行的指令的虚拟地址为 0040 1025H + 5 = 0040 102AH 。第 16 行的 call 指令采用相对寻址方式，即目标地址= (PC) +偏移量， call 指令的目标地址为 0040 1000H，所以偏移量=目标地址- (PC) = 0040 1000H - 0040 102AH = FFFF FFD6H。

​		根据第 16 行的 call 指令的偏移量字段为 D6 FF FF FF，可以确定 M 采用小端方式。

​	（4）因为 f(13) = 6227020800，其结果超出了 32 位 int 型数据可表示的最大范围，因此 f(13) 的返回值是一个发生了溢出的错误结果。为使 f1(13) 能返回正确结果，可将函数 f1 的返回值类型改为 double（或 long long，或 long double，或 float）类型。

​	（5）imul 指令最终结果放在 32 位的 eax 中，所以若乘积的高 33 位为非全 0 或非全 1，则 OF = 1。编译器应在 imul 指令后加一条 “溢出自陷指令”，使得  CPU 自动查询溢出标志 OF，当 OF=1 时调出“溢出异常处理程序”。

----

3. 【2021真题】假定计算机 M 字长为 16 位，按字节编址，连接 CPU 和主存的系统总线中地址线为 20 位、数据线为 8 位，采用 16 位定长指令字，指令格式及其说明如下：

​	![](E:\source\jk-english\英语语法初级\图片\4_64_大题题3图.png)

​		其中，op1 ~ op3 为操作码，rs、rt 和 rd 为通用寄存器编号，R[r] 表示寄存器 r 的内容，imm 为立即数，target 为转移目标的形式地址。请回答下列问题。

​	（1）ALU 的宽度是多少位？可寻址主存空间大小为多少字节？指令寄存器、主存地址寄存器（MAR）和主存数据寄存器（MDR）分别应有多少位?

​	（2）R 型格式最多可定义多少种操作？I 型和 J 型格式总共最多可定义多少种操作？通用寄存器最多有多少个？

​	（3）假定 op1 为 0010 和 0011 时，分别表示带符号整数减法和带符号整数乘法指令，则指令 01B2H 的功能是什么（参考上述指令功能说明的格式进行描述）？

​		若 1、2、3 号通用寄存器当前内容分别为 B052H、 0008H、0020H，则分别执行指令 01B2H 和 01B3H 后，3 号通用寄存器内容各是什么？各自结果是否溢出？

​	（4）若采用 l 型格式的访存指令中 imm（偏移量）为带符号整数，则地址计算时应对 imm 进行零扩展还是符号扩展？

​	（5）无条件转移指令可以采用上述哪种指令格式？

​		**答案：**

​	（1）ALU 的宽度为 16 位，ALU 的宽度即 ALU 运算对象的宽度，通常与字长相同。

​		地址线为 20 位，按字节编址，可寻址主存空间大小为 2<sup>20</sup> 字节（或 1MB)。

​		指令寄存器有 16 位， 和单条指令长度相同。

​		MAR 有 20 位，和地址线位数相同。MDR 有 8 位，和数据线宽度相同。

​	（2）R 型格式的操作码有 4 位， 最多有 2<sup>4</sup> = 16 种操作。

​		I 型和 J 型格式的操作码有 6 位，因为它们的操作码部分重叠，所以共享这 6 位的操作码空间，且前 6 位全 0  的编码已被 R 型格式占用， 因此 I 和 J 型格式最多有 2<sup>6</sup> -1 = 63 种操作。

​		从 R 型和 I 型格式的寄存器编号部分可知， 只用 2 位对寄存器编码， 因此通用寄存器最多有 2^2^ = 4 个。

​	（3）指令 01B2H = 000000 01 10 11 0010B 为一条 R 型指令，操作码 0010 表示带符号整数减法指令，其功能为 R[3] $\leftarrow$ R[1] - R[2]。

​		执行指令 01B2H 后，R[3] = B052H-0008H = B04AH，结果未溢出。

​		指令 01B3H = 000000 01 10 11 0011B，操作码 0011 表示带符号整数乘法指令。执行指令 01B3H 后，R[3] = R[1] x R(2] = B052H x 0008H = 8290H，结果溢出。

​	（4）在进行指令的跳转时，可能向前跳转，也可能向后跳转。偏移量是一个带符号整数， 因此在地址计算时，应对 imm 进行符号扩展。

​	（5）无条件转移指令可以采用 J 型格式， 将 taget 部分写入 PC 的低 10 位，完成跳转。 