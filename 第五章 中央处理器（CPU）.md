## 第五章 中央处理器（CPU）

### 5.1 本章大纲要求与核心考点

#### 5.1.1 大纲内容

（一）CPU 的功能和基本结构

（二）指令执行过程

（三）数据通路的功能和基本结构

（四）控制器的功能和工作原理

（五）异常和中断机制

1. 异常和中断的基本概念
2. 异常和中断的分类
3. 异常和中断的检测与响应

（六）指令流水线

1. 指令流水线的基本概念
2. 指令流水线的基本实现
3. 结构冒险、数据冒险和控制冒险的处理
4. 超标量和动态流水线的基本概念

（七）多处理器基本概念

1. SISD、SIMD、MIMD、向量处理器的基本概念
2. 硬件多线程的基本概念
3. 多核处理器（multi-core）的基本概念
4. 共享内存多处理器（SMP）的基本概念

#### 5.1.2 核心考点

​          本章知识点较多，综合性比较强。其中，指令流水线是历年考查的一个重点，数据通路、控制器原理出现的频率也很高，单项选择和综合应用题都有可能出现。本章单独出题一般以概念和原理为主，计算较少；往往会与第四章结合进行综合考查，有时也会结合第二章、第三章的内容。

​        需要掌握的内容包括：

- CPU 的基本结构，运算器和控制器的组成，各种寄存器的功能和特性。
- 指令周期的概念，指令执行的过程和方案。
- 数据通路的结构，数据通路中的数据传送流程和控制信号。
- 硬布线控制器的概念和原理；微程序控制器的概念和原理，微指令的编码方式及特点；两种控制器的比较。
- 异常和中断的概念和分类；异常和中断的响应过程。
- 指令流水线的概念、分类和原理；流水线冒险与处理方法；流水线的性能指标；超标量流水线。
- 多处理器的基本概念和分类。

#### 5.1.3 真题分布

  <table style="text-align:center">
      <tr>
          <th rowspan="2">考点</th>
          <th colspan="2">考查次数</th>
      </tr>
      <tr>
          <th>单项选择题</th>
          <th>综合应用题</th>
      </tr>
      <tr>
          <td>指令流水线</td>
          <td>10</td>
          <td>2</td>
      </tr>
      <tr>
          <td>控制器的功能和工作原理</td>
          <td>6</td>
          <td>5</td>
      </tr>
      <tr>
          <td>CPU的功能和基本结构</td>
          <td>5</td>
          <td>4</td>
      </tr>
      <tr>
          <td>数据通路的功能和基本结构</td>
          <td>3</td>
          <td>4</td>
      </tr>
      <tr>
          <td>指令执行过程</td>
          <td>2</td>
          <td>2</td>
      </tr>
      <tr>
          <td>多处理器的基本概念</td>
          <td>1</td>
          <td>0</td>
      </tr>



### 5.2 CPU 的功能和基本结构

#### 5.2.1 CPU 的功能

​		中央处理器（CPU）由 **运算器** 和 **控制器** 组成。![](E:\source\jk-english\英语语法初级\图片\1_9_细化的计算机组成框图-1723988473140.png)

​		运算器负责数据加工，也就是对数据进行算术和逻辑运算；而控制器则需要完成计算机各部件之间的协调和控制，保障每一条指令按规定的执行步骤正确执行，还要处理各项紧急事件。

​		计算机核心的功能就是自动执行一系列指令，这项工作主要由 CPU 中的控制器来完成。具体来说，指令的执行过程包括了 **取指令**、**分析指令** 和 **执行指令** 三个步骤。

![](C:\Users\wushengran\Desktop\组成原理\pictures\5_1_指令执行过程.png)

- 取指令：控制器能够自动地从存储器中取出指令，并且按预定的顺序依次取下一条指令。这要求控制器可以自动形成要执行的指令地址，并发出取指命令将对应的指令从主存取到控制器中。

- 分析指令：首先，控制器需要分析指令需要完成什么操作，从而发出对应的操作命令；其次，控制器需要分析操作数的地址，计算出有效地址。
- 执行指令：根据分析出的 “操作命令” 和 “操作数地址”，控制器就可以形成操作控制信号序列， 通过对运算器、主存以及 I/O 设备的操作，执行每条指令。

​		除此之外，控制器还必须能控制程序的输入和运算结果的输出，以及对总线（Bus）的控制，甚至需要处理一些运行中的异常情况和特殊请求。

​		所以总结起来，CPU 的功能包括：

- 数据加工：对数据进行算术和逻辑运算。

- 指令控制：控制程序的顺序执行，完成取指令、分析指令和执行指令的操作。
- 操作控制：产生完成每条指令的一系列操作命令，把各种控制信号送往相应的部件，使这些部件按指令的要求进行工作。
- 时间控制：对各种操作加以时间上的控制，为每条指令按时间顺序提供应有的控制信号。 
- 中断处理：对计算机运行中出现的异常情况和特殊请求进行处理。

#### 5.2.2 CPU 的基本结构

​		根据 CPU 的功能可以看出，数据的运算需要由运算器来完成，剩下的功能则由控制器完成。

![](E:\source\jk-english\英语语法初级\图片\5_2_CPU的结构.png)

##### 1. 运算器

​		运算器需要对数据进行运算，所以核心部件是 **算术逻辑单元（ALU）**，此外还有一系列的 **寄存器** 用来缓存数据、运算结果和状态。

​		运算器中的寄存器主要有暂存寄存器、累加寄存器（ACC）、通用寄存器组（GPRs）、程序状态字寄存器（PSW）等。

- 暂存寄存器：用于暂存从主存读来的数据。

- 累加寄存器（ACC）：用于暂存 ALU 的运算结果，可以作为加法运算的一个操作数再次输入 ALU。

- 通用寄存器组：通用功能的一组寄存器，主要用于存放操作数和地址信息。

- 程序状态字寄存器（PSW）：对于算术/逻辑运算指令或测试指令的运行结果，专门用一个寄存器 PSW 来保存各种状态信息，也叫 **条件码寄存器**。典型的条件码有溢出标志（OF）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。

​		这些寄存器对于程序员来说，除了暂存寄存器一般是透明的，其它都是可见的。

##### 2. 控制器

​		控制器是计算机中负责协调控制的部件，主要功能就是取指令、分析指令、执行指令。

​		控制器需要根据指令中操作码、指令的执行步骤以及当前状态字信息，来生成一系列对计算机各部件的控制信号（也叫做 “**微操作**”），这个专门的部分就叫做 **“控制单元”（CU）**。

​		为了准确地取出指令，需要一个寄存器来保存下一条指令的地址，这就是 **程序计数器（PC）**；取出的指令同样也需要先保存下来再做分析，存放指令的寄存器就是 **指令寄存器（IR）**，另外还需要一个 **指令译码器（ID）**来对指令操作码进行译码。最后，还需要有 **中断系统** 来处理异常情况和特殊请求。

​		MAR 和 MDR 一般也会集成在控制器中。因此控制器内的寄存器主要有：

- 程序计数器（PC）：存放下一条指令的主存地址。

- 指令寄存器（IR）：存放取出的指令。
- 主存地址寄存器（MAR）：存放要访问的主存单元的地址。

- 主存数据寄存器（MDR）：存放要向主存写入或从主存读出的信息。


​		这些寄存器的功能主要是控制指令的执行过程，因此大多数情况下对用户是透明（不可见）的。不过一般情况下计算机允许汇编程序员访问程序计数器（比如 x86 架构下的 IP），因此 PC 可以认为对汇编程序员来说是可见的。

​		除此之外，CPU 中一般还会包含 **高速缓存（Cache）**和 **内存管理单元（MMU）**，以及用于数据传输的内部数据总线和产生时序信号的时序电路。

### 5.3 指令周期

#### 5.3.1 指令周期的概念

​		计算机取出并执行完一条指令所需的全部时间，就叫做 **指令周期**。

![](E:\source\jk-english\英语语法初级\图片\5_1_指令执行过程.png)

​		我们已经知道，一条指令的执行过程可以分为 **取指令**、**分析指令** 和 **执行指令** 三个步骤，因此一个指令周期也应该包含这三部操作需要的时间。由于分析指令时可以用硬件实现操作码的译码，因此这步操作用时很短，一般可以将取指令和分析指令合并为一个阶段，对应的时间称为 **取指周期**；而执行指令阶段所需的时间就称为 **执行周期**。

![](E:\source\jk-english\英语语法初级\图片\5_3_指令周期.png)

​		很明显，各种指令的取指周期是一样的，但由于具体的执行操作不同，执行周期各不相同；因此指令周期是可以不同的。

​		前面我们将 ”分析指令“ 这一步合并入了取指周期，是因为操作码的译码非常简单；但分析指令不仅仅要对操作码进行译码，还需要根据形式地址得到有效地址。在间接寻址的方式下，指令字中给出的是 ”地址的地址“，所以需要先访问主存一次、取出有效地址，然后再次访问主存取出操作数。这个阶段称为 **间址周期**。

![](E:\source\jk-english\英语语法初级\图片\5_4_具有间址周期的指令周期.png)

​		此外，计算机在执行过程中，可能会出现异常情况或者特殊请求，这时需要进行中断处理。所以 CPU 会在每条指令执行阶段结束前，发出 ”中断查询信号“，检测是否有某个 I/O 设备提出了中断请求；如果有，则 CPU 进入中断响应阶段，称为 **中断周期**。中断周期中 CPU 需要将程序断点保存到存储器中。

​									![](E:\source\jk-english\英语语法初级\图片\5_5_指令周期处理流程.png)

​		所以，一个完整的指令周期应该包括 取指、间址、执行 和 中断 4 个部分。间址和中断周期不一定会包含在指令周期中。这 4 个周期内都会有访存操作，又可称为 CPU 的 ”工作周期“。

- 取指：访问主存取出指令
- 间址：访问主存获取有效地址
- 执行：从主存中取操作数，或将结果写入主存
- 中断：将程序断点保存到主存

​		在 CPU 的硬件底层，为了区分不同的工作周期、更方便地设计控制单元 CU，往往会设置一组 CPU 工作周期的 ”标志触发器“。

![](E:\source\jk-english\英语语法初级\图片\5_6_CPU工作周期的标志触发器.png)

​		上面的 4 个 D 触发器 FE、IND、EX 和 INT 就对应了指令周期的取指（fetch）、间址（indirect addressing）、执行（execute）、中断（interrupt） 4 个阶段，以 ”1“ 状态来表示有效。在取指阶段，只要设置 FE 为 1，就可以由它控制取指阶段的各步操作；当取指结束、进入间址周期时，只要将 FE 置 0、IND 置 1 就可以了。

#### 5.3.2 时钟周期和机器周期

##### 1. 时钟周期

​		计算机是由 **时钟信号** 来控制时间顺序的。

​		时钟信号是由机器中的主振电路（比如晶体振荡器）发出脉冲信号后，经整型或分频后产生。时钟信号的宽度称为 **时钟周期**，时钟信号的频率就是 CPU 的 **主频**，时钟周期和机器主频互为倒数。时钟周期是 CPU 工作的最小时间单位。

​		![](E:\source\jk-english\英语语法初级\图片\5_7_CPU时钟信号.png)

​		用时钟信号控制节拍发生器，可以产生 **节拍**；每个节拍的宽度就对应着一个时钟周期。在一个节拍内，机器可以完成一个最小的操作（微操作），或者是几个需要同时执行的操作。

##### 2. 机器周期

​		每条指令都可以包含四个不同的阶段，每个阶段都至少会访问一次主存。

​		由于访问主存占据了大部分时间，需要一次访存的操作耗时都差不多，因此我们可以设置一个统一的 ”基准时间“，在这个基准时间内，所有阶段的操作都可以完成；这个基准时间就被称为 **机器周期**。

![](E:\source\jk-english\英语语法初级\图片\5_8_定长的机器周期.png)

​		可以看到，一个指令周期包含了若干个机器周期，而一个机器周期又包含若干时钟周期。

​		上面的例子中，每个机器周期都是相等的，包含 4 个节拍（时钟周期），这是定长的机器周期；如果每个机器周期中包含的节拍数不等，就是不定长的机器周期：

![](E:\source\jk-english\英语语法初级\图片\5_9_不定长的机器周期.png)

​		不定长的机器周期更适合比较简单的指令，它可以跳过一些不需要的时钟周期，从而让整个指令周期变短。我们可以默认给一个较短的机器周期，对于比较复杂的操作，则通过增加节拍、通过延长机器周期来解决。

#### 5.3.3 处理器的设计方式

​		针对指令周期采用不同的方式，可以设计出不同类型的 CPU。

##### 1. 单周期处理器

​		单周期处理器中，指令周期固定为 **一个时钟周期**。

​		在这种方式下，所有的指令都在相同的时间内执行完成，把这个时间就设置为时钟周期，因此 CPI 为 1。因为指令是串行执行的，这样，时钟周期就会以最慢的指令的执行时间为准，从而导致 CPU 主频较低、运行速度较慢。

​		单周期处理器实现比较简单，但性能较差，不能充分利用硬件资源。

##### 2. 多周期处理器

​		多周期处理器，则是指每条指令需要若干个时钟周期来完成。

​		一般来说，多周期处理器会将整个 CPU 的指令执行过程分成几个阶段，每个阶段又用若干个时钟周期去完成，然后开始下一条指令的执行。这样，各种指令执行需要的时钟周期数就可能不同。

​		多周期 CPU 可以更加充分地利用硬件资源，提升执行效率。不过由于每种指令的执行时间不同，需要对指令进行分类，实现起来较为复杂。

##### 3.  流水线处理器

​		流水线处理器同样会将 CPU 执行指令的过程分为几个阶段，而每个阶段都占用相同的时间（机器周期）；在同一时间，在计算机的各个部件上可以依次执行每条指令的不同阶段，就像在流水作业线上处理指令一样。

​		这样的方式使得指令可以并行执行，大大提升了系统运行效率。每个机器周期，CPU 都会取出一条新的指令；如果以机器周期作为时钟周期，那么理想情况下，流水线的执行效率可以做到接近于每个时钟周期处理 1 条指令，即 CPI 为 1。

### 5.4 指令流水线

​		对于计算机系统而言，提升器件性能和改进系统结构，是提高整体性能的两大途径。**指令流水线** 就是改进处理器架构的一项并行处理技术，可以极大地提高 CPU 的工作效率。

​		计算机中的并行性体现在不同的级别上。通常可以分为以下 4 个级别：

- 作业级/程序级
- 任务级/进程级
- 指令之间级
- 指令内部级

​		前两个级别是粗粒度的，又称为 **过程级**，一般用软件算法实现；而后两个级别是细粒度的，又称为 **指令级**，一般用硬件实现。指令流水线就是一项实现指令级并行的技术。

#### 5.4.1 指令流水线的基本概念和原理

##### 1. 流水线的概念和原理

​		类似于工厂中流水装配线的思想，指令的执行过程也可以分成不同的阶段，每个阶段需要的 CPU 部件是不同的；所以 CPU 各个部件可以同时对不同的指令进行处理，这就是指令流水线。

​		如果只把指令处理过程分成两个阶段：取指令和执行指令，那么没有采用流水线的计算机会串行处理每条指令：

![](E:\source\jk-english\英语语法初级\图片\5_10_未采用流水线的指令执行过程.png)

​		取指令的操作可以由取指部件完成，执行指令的操作则可以由执行部件完成。所以这种顺序执行的方式尽管实现简单，但是对硬件的利用率不高。

​		如果采用流水线，则可以在时间上将不同指令的执行 ”重叠“ 起来，实现并行的效果：

![](E:\source\jk-english\英语语法初级\图片\5_11_采用流水线的指令执行过程.png)

​		划分两个阶段，可以同时有两条指令重叠，这称为指令的 **二级流水**。

​		理论上讲，二级流水线同时有两条指令执行，相当于可以将指令周期减半、速度提升一倍。

##### 2. 六级流水线

​		为了进一步提升处理速度，可以将指令的处理过程划分成更为细致的几个阶段：

- 取指（FI）：从主存取出一条指令，并暂存在缓冲区（IR）中。
- 指令译码（DI）：确定操作方式和操作数的寻址方式。
- 计算操作数地址（CO）：根据寻址方式，计算操作数的有效地址。
- 取操作数（FO）：从主存中取出操作数（如果在寄存器中，则可以跳过这个阶段）。
- 执行指令（EI）：执行指令的具体操作，将结果存放在目的位置（寄存器）。
- 写操作数（WO）：将结果写入主存。

​		共有 6 个阶段，所以可以构建出六级流水线。流水线中各阶段应该有相同的机器周期，这里我们可以假设以上各段时间相同。对应的指令六级流水时序图如下：

![](E:\source\jk-english\英语语法初级\图片\5_12_指令的六级流水时序.png)

​		这样的流水线处理器中，应该设计 6 个操作部件，可以同时处理 6 条指令，从而大大提高了程序的运行速度。假设机器周期就等于时钟周期，也就是每个阶段用时是 1 个时钟周期，那么流水线可以做到 CPI 接近于1。

​		当然，实际的流水线远远达不到这样的性能。流水线也有很多问题：

- 实际处理器中，每条指令不一定包含了完整的 6 个阶段；
- 实际的处理器中，指令处理的各个阶段时间不会相同；
- 这里需要假设不存在同时访存的冲突，所以所有指令都可以同时并行；实际情况下，指令可能存在冲突；
- 当遇到条件转移指令时，下一条指令是无法提前确定的，只能根据前一条指令的执行结果来判断，时间上会有损失。

##### 3. 流水线处理器的设计原则

​		流水线处理器设计的基本原则，就是：

- 机器周期应该是定长的，并且以用时最长的处理阶段为准；它对应着每个流水线阶段（简称 ”流水段“ ）的时间长度。
- 流水段的个数，应该以最复杂指令的处理阶段数量为准；

​		很明显，如果 CPU 采用的指令集比较复杂，流水线的效率就会大打折扣。所以更有利于实现流水线的指令集架构，应该满足：

- 尽量采用定长指令字；
- 尽量简化指令的功能，每条指令只完成最基本的功能；
- 简化寻址方式，每条指令都可以在较短的时间内得到需要的有效地址；
- 使用 load / store 体系结构，只有 load / store 指令可以进行访存操作；
- 使用大量寄存器，尽量减少访存操作。

​		可以看出，这些都是 RISC 的特点。所以说，RISC 更加有利于实现流水线；而具体实现中，一般会将每个阶段的机器周期设为一个时钟周期，这样大部分指令都可以在一个时钟周期完成完成。

#### 5.4.2 流水线冒险

​		在指令流水线中，往往会出现一些造成 ”断流“ 的情况，导致流水线无法正确处理指令，这就是 **流水线冒险**。

​		流水线冒险主要有三种：**结构冒险**、**数据冒险** 和 **控制冒险**。

​		我们可以先考虑一个具体的案例。假设现在有一个五级流水线，5个阶段设计分别为：取指令（FI）、指令译码/读寄存器（ID）、执行/计算有效地址（EX）、访存（MEM）、结果写回寄存器（WB）。那么不同类型的指令，在各流水段的操作也有所不同：

![](E:\source\jk-english\英语语法初级\图片\5_13_不同类型指令在各流水段中的操作.png)

​		接下来考虑三种不同的流水线冒险。

##### 1. 结构冒险

​		当流水线中多条指令重叠执行时，不同指令可能会争用同一功能部件而产生资源冲突，这就是 **结构冒险**，也称为资源相关。

​		例如，取指阶段 IF 和访存阶段 MEM 都需要访问主存，而冯诺依曼架构的计算机大多会把指令和数据保存在同一个存储器中、且只有唯一的访问口。那么如果在某个时钟周期内，流水线上某一条指令处在 IF 阶段、另一条指令处在 MEM 阶段，就会发生访存冲突。

![](E:\source\jk-english\英语语法初级\图片\5_14_结构冒险.png)

​		上表中，在第 4 个时钟周期，第 i 条指令 LOAD 处于 MEM 段，正在访问主存；而同时第 i + 3 条指令处于 IF 段，也需要访问主存取指：于是产生了冲突。

​		解决方案是可以让后一条指令暂停一个时钟周期，等前一条指令完成访存操作后，再开始取指。

![](E:\source\jk-english\英语语法初级\图片\5_15_用暂停解决结构冒险.png)

​		另一种方案是，可以设置两个独立的存储器，分别存放指令和数据，这样就可以从根本上避免冲突。另外也可以采用 ”指令预取“ 技术，在 CPU 中设置指令队列，将指令预先取出来放到队列中排队。

##### 2. 数据冒险

​		在流水线中，指令之间可能会有数据的关联。如果一条指令的执行，需要用到之前指令的计算结果；那么当之前的指令尚未执行结束时，下一条指令就直接开始读取数据，就会产生冲突。这种情况被称为 **数据冒险**。

​		例如，流水线中有下面两条连续的指令：

​		ADD    R~1~，R~2~，R~3~								（R~2~）+（R~3~）→ R~1~

​		SUB     R~5~，R~1~，R~4~								（R~1~）-（R~4~）→ R~5~

​		这里，第一条指令将 R~2~ 和 R~3~ 中的数据相加，结果放入 R~1~；然后第二条指令又将 R~1~ 中的数据取出，跟 R~4~ 的值做减法，结果写入 R~5~。

​		在不采用流水线时，按照顺序执行是完全没有问题的；但当采用了流水线结构后，这种 ”先写后读“ 的顺序就发生了变化：

![](E:\source\jk-english\英语语法初级\图片\5_16_数据冒险.png)

​		在第 3 个时钟周期，SUB 指令就开进入指令译码、读取寄存器 R~1~ 的数据了；而要到第 5 个时钟周期，ADD 指令才会将真正的计算结果写回。”先写后读“ 就变成了 ”先读后写“，产生了数据相关的冲突。

​		根据指令间对数据读写操作的先后顺序，数据冒险可以分成三类：

- 写后读（Read After Write，RAW）：也就是先写后读，如果试图写入前就读取，就会读出错误的 **旧** 内容；
- 读后写（Write After Read，WAR）：也就是先读后写，如果试图读取前就写入，就会读出错误的 **新** 内容；
- 写后写（Write After Write，WAW）：两次连续的写入，如果改变了写入顺序，最后保存的数据就是先写入的值；

​		如果只考虑按顺序流动的流水线，那其实只会出现 RAW 相关的情况；而假如是非按序流动的流水线，允许后面的指令超过前面的指令、先流出流水线，那就还可能发生 WAR 和 WAW 的情况。

​		解决数据冒险可以采用下面的方法：

（1）后推法

​		要想解决数据冒险，最简单的解决方案，还是先将后面的指令暂停，等前面指令完成、生成所需的结果之后再继续进行。这种方法称为 **后推法**。

​		例如，我们再增加几个指令，构成一个指令序列：

​		ADD    R~1~，R~2~，R~3~								（R~2~）+（R~3~）→ R~1~

​		SUB     R~5~，R~1~，R~4~								（R~1~）-（R~4~）→ R~5~

​		AND    R~7~，R~1~，R~6~								（R~1~）AND（R~6~）→ R~7~

​		OR       R~9~，R~1~，R~8~								（R~1~）OR（R~8~）→ R~9~

​		XOR     R~11~，R~1~，R~10~							（R~1~）AND（R~10~）→ R~11~

​		第一条 ADD 指令将 R~2~ 和 R~3~ 相加的结果写入 R~1~，之后的 4 条指令 SUB、AND、OR、XOR 都要使用 R~1~ 中的值作为一个源操作数。这里就出现了 RAW 数据冒险。

![](E:\source\jk-english\英语语法初级\图片\5_17_数据冒险案例.png)

​		如果采用后推法，将后续指令延迟到 ADD 指令完成写回 WB 阶段之后，就可以解决数据冒险：

![](E:\source\jk-english\英语语法初级\图片\5_18_后推法解决数据冒险.png)

（2）专用通路技术（数据旁路技术）

​		另一种解决方案是采用定向技术，也叫 **专用通路技术** 或 **旁路技术**。

​		基本思想是，上一条指令的运行结果，在 EX 阶段就已经产生；那就不必等到上一条指令后续阶段全部完成（写回寄存器），可以直接将结果送到后续指令需要的地方。这样流水线就可以不发生停顿。

​		由于需要对后续指令进行数据的定向传送操作，所以应该加入另外的部件。

​										![](E:\source\jk-english\英语语法初级\图片\5_19_带有旁路技术的ALU.png)

​		上图就是一个带有旁路技术的 ALU 部件。ADD 指令执行的结果，会存入 **暂存器** 中；而暂存器的结果又会通过旁路通道，经多路开关直接送回 ALU 参与后续的计算。这里的定向传送，只发生在 ALU 内部。

##### 3. 控制冒险

​		**控制冒险** 主要是由 **转移指令** 引起的。当遇到条件转移指令（分支指令）时，由于只有上一条指令执行结束才能知道是否跳转，因此一般我们只能采用猜测法，默认不发生跳转、继续取下一条指令；如果真的发生了跳转，这时之前的操作全部作废，需要重新按照 PC 跳转的位置取指执行。这就破坏了流水线的连续流动。

​		还是用之前的六级流水线的例子，假设指令 3 是一条条件转移指令。

![](E:\source\jk-english\英语语法初级\图片\5_20_控制冒险.png)

​		指令 3 是条件转移指令，所以只有在第 7 个时钟周期（时间单元）、指令 2 执行完毕之后才能判断是否进行跳转：如果不跳转，则继续执行指令 4；如果跳转，则执行指令 15。

​		采用猜测法，默认不跳转，所以流水线继续取指令 4，并正常向前流动；但当到第 7 个时钟周期时，发现结果满足条件，需要进行跳转，则之前第 4、5、6、7 个时钟周期所做的操作全部作废，第 8 个时钟周期重新取指令 15，继续流水线的流动。在第 9 ~12 个时钟周期内，没有指令完成，这是预测失败带来的转移损失。

​		据统计，转移指令大约占到了程序总指令数的 1/4，所以控制冒险会严重影响流水线的性能。为了解决控制冒险，可以采用下面的方法：

- 尽早判别转移是否发生，尽早生成转移目标地址。

- 预取转移成功和不成功两个控制流方向上的目标指令。

- 加快和提前形成条件码。

- 提高转移方向的猜测率。


#### 5.4.3 流水线的性能指标

​		流水线的性能，一般用三项指标来衡量：**吞吐率**、**加速比**、**效率**。

![](E:\source\jk-english\英语语法初级\图片\5_12_指令的六级流水时序.png)

##### 1. 吞吐率

​		单位时间内流水线所完成的指令数，或者输出结果的数量，称为流水线的 **吞吐率**。吞吐率又有两种：

（1）最大吞吐率

​		最大吞吐率是指流水线在连续流动达到稳定状态后，所获得的吞吐率。对于 m 段的指令流水线，假设各段的时间均为 Δt，那么达到稳定状态后，每个 Δt 都会完成一条指令；所以最大吞吐量就是：
$$
T_{pmax} = \frac{1}{Δt}
$$
​		流水线只有在达到稳定、连续流动的时候，才能获得最大吞吐率。实际上，流水线在开始时有一段建立时间，结束时又有一段排空时间；另外还有各种冒险因素使流水线无法连续流动，所以实际吞吐率总是小于最大吞吐率。

（2）实际吞吐率

​		假设流水线中总共有 n 条指令，完成 n 条指令的总时间为 t，那么实际吞吐率就是 n / t。同样，对于 m 段指令流水线，若各段时间为 Δt，那么连续处理 n 条指令时，除了第 1 条指令需要 m · Δt 时间，其它 n - 1 条指令都是每隔 Δt 就会完成一条。所以：
$$
t = m \cdot Δt \space + (n-1)\cdot Δt
$$
​		这样，实际吞吐率的计算公式为：
$$
T_p = \frac{n}{t} = \frac{n}{m \cdot Δt \space + (n-1)\cdot Δt} = \frac{n}{(m+n-1)\cdot Δt}
$$
​		带入最大吞吐率的公式，可以得到：
$$
T_p = \frac{n}{m+n-1} \cdot T_{pmax} = \frac{1}{1+(m-1)/n} \cdot T_{pmax}
$$
​		很明显，实际吞吐率 T~p~ < T~pmax~，当 n → +∞ 时，T~p~ 趋近于 T~pmax~。

##### 2. 加速比

​		流水线的加速比，指的是采用流水线处理指令的速度，和同样功能的非流水线的速度之比。

​		如果流水线每段时间均为 Δt，那么同样是完成 n 条指令，使用 m 段流水线需要的时间为：
$$
t = m \cdot Δt \space + (n-1)\cdot Δt
$$
​		而不使用流水线时需要时间为
$$
t' = n \cdot m \cdot Δt
$$
​		则加速比 S~p~ 为：
$$
S_p = \frac{v}{v'} = \frac{t'}{t} = \frac{n \cdot m \cdot Δt}{m \cdot Δt \space + (n-1)\cdot Δt} = \frac{n \cdot m}{m+n-1} = \frac{m}{1+(m-1)/n}
$$
​		可以看出，当 n → +∞ 时，S~p~ 趋近于 m，也就是流水线的最大加速比等于流水线的段数。

##### 3. 效率

​		流水线的效率，是指流水线中各功能段的利用率。

​		因为流水线有建立时间和排空时间，所以各功能段设备不会一直处于工作状态，会有一段空闲时间。假设 m 段流水线各段时间均为 Δt，我们可以将每个功能段（空间）在每个 Δt（时间）内的工作状态画出来，这就是流水线的 “**时空图**”：

![](E:\source\jk-english\英语语法初级\图片\5_21_流水线的时空图.png)

​		上图是一个 4 段流水线（m = 4）的时空图，那么处理 n 条指令一共需要时间为 m · Δt + (n-1) · Δt，在时空图上总的时空区域为：m · (m+n-1) · Δt ；而各段真正处于工作的时空区域为：m · n · Δt。

​		一般就用流水线各段处于工作的时空区域，和总时空区域的比值，来衡量流水线的效率。计算公式为：
$$
E = \frac{m \cdot n \cdot Δt}{m \cdot (m+n-1) \cdot Δt} = \frac{n}{m+n-1} = \frac{S_p}{m} = T_p \cdot Δt
$$

#### 5.4.4 流水线的多发技术

​		流水线技术大大提升了 CPU 的处理效率，给计算机系统结构带来了重大改进。通过开发流水线的多发技术，又可以进一步地对流水线进行改进和提升。

​		所谓的多发技术，就是设法提升流水线的并行效果，尽量在一个时钟周期内可以完成更多的指令。常见的多发技术有 **超标量技术**、**超流水线技术** 和 **超长指令字技术**。

##### 1. 超标量技术

​		超标量（SuperScalar）流水线技术也叫做动态多发射技术，它是指在每个时钟周期内，可以同时并发多条独立的指令；也就是以并行操作的方式，将两条或两条以上的指令编译执行。

![](E:\source\jk-english\英语语法初级\图片\5_22_超标量流水线.png)

​		上图是普通流水线和超标量流水线的对比。这里是一条四级流水线，处理一条指令分为 4 个阶段：**取指（IF）**、**译码（ID）**、**执行（EX）**和 **写回（WR）**。假设每段时间就是一个时钟周期。

​		可以看到，普通流水线每个时钟可以产生一条指令的结果；而超标量流水线每个时钟周期都可以产生多条指令的结果。

​		要实现超标量技术，CPU 中要配置多个功能部件和指令译码电路，以及多个寄存器端口和总线，以便能够实现同时执行多个相同阶段的操作。另外，还需要编译器采用编译优化技术，找到能并行执行的指令进行调配。

##### 2. 超流水线技术

​		超流水线（SuperPipeline）技术是将一些流水线寄存器插入到流水线段中，相当于把每个阶段再进行细分。

![](E:\source\jk-english\英语语法初级\图片\5_23_超流水线.png)

​		上图中原来的一个时钟周期又分成了三段。这样超流水线的处理器可以在一个时钟周期内，让功能部件处理 3 条指令；相当于流水线是以 3 倍于原时钟频率的速度运行。

##### 3. 超长指令字技术

​		超长指令字技术（VLIW）也称静态多发射技术，它和超标量技术有共同特点，都是采用多条指令在多个部件中并行处理的架构，从而在一个时钟周期内能够流出多条指令。

![](E:\source\jk-english\英语语法初级\图片\5_24_超长指令字.png)

​		跟超标量技术的区别在于：超标量的指令来自同一标准的指令流；而超长指令字则是由编译器挖掘出指令间潜在的并行性，然后把多条能并行的指令直接组合成一条指令——这是一条具有多个操作码字段的超长指令。这条超长指令可以控制机器中的多个独立的功能部件同时操作，相当于同时执行了多条指令。

​		超长指令字技术比超标量有更高的并行处理能力，但对编译器优化的要求更高，对 Cache 容量的要求更大。

### 5.5 数据通路和控制信号

#### 5.5.1 数据通路的概念和功能

​		计算机中，将各个功能部件连接起来、可以进行数据传送的路径称为 **数据通路**。

![](E:\source\jk-english\英语语法初级\图片\5_2_CPU的结构.png)

​		数据通路的主要功能，就是实现计算机中不同部件间的信息传送和数据交换。在这里我们主要讨论 CPU  内部的数据通路，它描述了信息在 CPU 内各部件之间传递的路径，也包括了路径上流经的部件，比如 ALU、寄存器、中断系统等。

#### 5.5.2 指令周期中的数据流

​		CPU 的指令周期可以分为取指、间址、执行和中断四个阶段，在不同的阶段，控制器应该产生不同的控制信号。我们可以先来分析一下每个阶段中数据的流动方向，这就是指令周期中的 **数据流**。

##### 1. 取指周期

​		这里我们只讨论 CPU 中最重要的 4 个寄存器 PC、IR、MAR 和 MDR。MAR 与地址总线相连，存放要访问的存储单元地址；MDR 与数据总线相连，存放从主存中读出的或者要写入主存的数据；PC 存放要执行的指令地址，有 “自动加 1” 的计数功能；IR 存放正在执行的指令。

<img src="C:/Users/18133/Desktop/课件/pictures/5_25_取指周期数据流.png" style="zoom:90%;" />

​		① 将 PC 中存放的当前指令的地址，送到 MAR；

​		② 将 MAR 中的地址送至地址总线；

​		③ CU 发出读命令，经控制总线到达主存；

​		④ 主存中对应存储单元的内容（指令）经数据总线，传送给 MDR；

​		⑤ MDR 中的内容送至 IR，并将操作码交给 CU 进行译码；

​		⑥ CU 控制 PC 内容加 1，形成下一条指令的地址。

##### 2. 间址周期

​		取指周期结束后，CU 就会检查 IR 中的内容，判断寻址方式；如果有间接寻址，就执行间址周期中的操作。

![](E:\source\jk-english\英语语法初级\图片\5_26_间址周期数据流.png)

​		① 取 MDR（或 IR）中的地址码，记作 Ad (MDR)，送至 MAR；

​		② 将 MAR 中的地址送至地址总线；

​		③ CU 发出读命令，经控制总线到达主存；

​		④ 主存中对应存储单元的内容（地址）经数据总线，传送给 MDR；

​		⑤ 将有效地址传送到 IR 的地址字段（在一些机器中，这一步可以省略）。

##### 3. 执行周期

​		在执行周期，可能会涉及到对 ALU 的操作、寄存器之间的数据传递，以及对主存的读写操作。因为不同的指令在执行周期会有不同的操作，对应的数据流也会有所不同，所以不能用同一的数据流图来表示。

##### 4. 中断周期

​		CPU 进入中断周期后，会进行一系列的操作；核心部分就是要将当前程序执行的状态保存下来，等到中断服务程序执行完毕后再返回继续执行。

![](E:\source\jk-english\英语语法初级\图片\5_27_中断周期数据流.png)

​		① CU 将一个特殊地址（比如 0 地址）送至 MAR，这个地址对应的存储单元保存程序的断点信息，主要就是 PC 的值；

​		② 将 MAR 中的地址送至地址总线；

​		③ CU 发出写命令，经控制总线到达主存；

​		④ 将 PC 的内容（程序断点位置）传送给 MDR；

​		⑤ 将 MDR 中的断点信息经数据总线，存入主存中；

​		⑥ CU 将中断服务程序的入口地址送至 PC，准备执行中断服务程序。

#### 5.5.3 指令周期的微操作

​		数据通路上的每条线路，都会有一个允许数据进出的 “门”，可以控制当前线路是否开启数据的传送；一般可以用三态门来实现。

![](E:\source\jk-english\英语语法初级\图片\5_28_三态门电路符号.png)

​		上面的三态门可以等效地看成：

![](E:\source\jk-english\英语语法初级\图片\5_29_三态门等效电路png.png)

​		在不同的时钟周期，给出不同的三态门控制端 EN 信号，就可以精确地控制每条线路依次导通。

​		CPU 的控制器可以根据每条指令的具体操作，生成一系列的控制信号，控制数据通路上每个三态门在不同时钟周期的 “开” 和 “关”，从而起到控制指令执行的过程。这样的控制信号，就被称为 “**微操作**” 或者 “**微指令**”。

​		下面我们依然根据指令周期的 4 个阶段，分别分析对应的微操作命令。

##### 1. 取指周期

​		对应上一小节分析的取指令过程，可以归纳为以下几个微操作：

![](E:\source\jk-english\英语语法初级\图片\5_30_取指周期微操作.png)

##### 2. 间址周期

![](E:\source\jk-english\英语语法初级\图片\5_31_间址周期微操作.png)

##### 3. 执行周期

​		在执行周期，不同指令的微操作是不同的。这里我们将指令按照功能分为非访存指令、访存指令和转移指令来进行分析。

**（1）非访存指令**

​		这类指令一般只是执行一步简单的操作，在执行周期不访问主存。

<img src="C:/Users/18133/Desktop/课件/pictures/5_32_执行周期微操作_非访存指令.png" style="zoom:80%;" />

**（2）访存指令**

​		这类指令在执行阶段需要访问存储器，例如一个操作数在主存中的加法指令，以及从主存中存取数据的指令。简单起见，我们这里只讨论直接寻址的情况。

![](E:\source\jk-english\英语语法初级\图片\5_33_执行周期微操作_访存指令.png)

**（3）转移指令**

​		转移指令只是通过对 PC 的更改，实现指令执行的跳转，因此执行阶段也不需要访问主存。

![](E:\source\jk-english\英语语法初级\图片\5_34_执行周期微操作_转移指令.png)

##### 4. 中断周期

![](E:\source\jk-english\英语语法初级\图片\5_35_中断周期微操作.png)

#### 5.5.3 数据通路的基本结构和控制信号

​		CPU 外部和主存、I/O 设备的连接，一般采用总线方式。而 CPU 内部数据通路的结构，其实就是 CPU 内部的连线方式。根据 CPU 内是否采用总线方式进行连接，数据通路可以分为两种结构。

##### 1. 不采用 CPU 内部总线

​		如果不采用 CPU 内部总线的方式，就需要将 CPU 内的所有需要进行数据传递的部件单独连接起来，相当于为两者之间搭建了一条 “专线”，所以这种方式也叫做 **专用数据通路** 方式。

​		这种专用数据通路中所有的路径都是 “专线专用”，不存在冲突，因此性能更好；但所有部件之间都需要进行线路连接，布线比较复杂，硬件成本较高，可扩展性比较差。

<img src="C:/Users/18133/Desktop/课件/pictures/5_36_专用数据通路.png" style="zoom:100%;" />

​		上图就是未采用总线方式时的数据通路和控制信号。为了简便这里没有画出每个部件输入输出通路的控制门，只用一个小圆圈代替，上面用箭头标出了每个门电路的控制信号 C~i~ 。

---

​		接下来以一条采用了间接寻址的加法指令为例：

```
   ADD @ X
```

​		这条指令中 @ 是间接寻址标志，X 是存放操作数地址的存储单元地址。需要间接寻址取出操作数，与寄存器 ACC 的值相加，得到的结果再写回 ACC 中。我们依然按照指令周期的不同阶段来进行分析：

**（1）取指周期**

<img src="C:/Users/18133/Desktop/课件/pictures/5_37_专用数据通路_取指周期.png" style="zoom:80%;" />

​		① 控制信号 C~0~ 有效，打开 PC 送往 MAR 的控制门：（PC）→ MAR；

​		② C~1~ 有效，打开 MAR 送往地址总线（AB）的输出门：（MAR）→ M（主存）；

​		③ CU 通过控制总线（CB）向主存发出读命令（R）：1 → R；

​		④ C~2~ 有效，打开数据总线（DB）送至 MDR 的输入门：M (MAR) → DB → MDR；

​		⑤ C~3~ 有效，打开 MDR 和 IR 之间的控制门，将指令传送至 IR：（MDR）→ IR；

​		⑥ C~4~ 有效，打开指令的操作码送往 CU 的输出门：OP(IR) → CU；

​			CU 在指令操作码和时钟信号的控制下，就可以进一步产生各种控制信号了。

​		⑦ PC 内容加 1： （PC）+ 1 → PC 

**（2）间址周期**

<img src="C:/Users/18133/Desktop/课件/pictures/5_38_专用数据通路_间址周期.png" style="zoom:80%;" />

​		① C~5~ 有效，打开 MDR 和 MAR 之间的控制门，将指令中的形式地址送至 MAR：Ad (MDR) → MAR；

​		② C~1~ 有效，打开 MAR 送往地址总线（AB）的输出门：（MAR）→ AB → M（主存）；

​		③ CU 通过控制总线（CB）向主存发出读命令（R）：1 → R；

​		④ C~2~ 有效，打开数据总线（DB）送至 MDR 的输入门，将有效地址写入 MDR：M (MAR) → DB → MDR

​			至此，就获取到了指令操作数的有效地址。

**（3）执行周期**

<img src="C:/Users/18133/Desktop/课件/pictures/5_39_专用数据通路_执行周期.png" style="zoom:80%;" />

​		① C~5~ 有效，打开 MDR 和 MAR 之间的控制门，将有效地址送至 MAR： (MDR) → MAR；

​		② C~1~ 有效，打开 MAR 送往地址总线（AB）的输出门：（MAR）→ AB → M（主存）；

​		③ CU 通过控制总线（CB）向主存发出读命令（R）：1 → R；

​		④ C~2~ 有效，打开数据总线（DB）送至 MDR 的输入门，将操作数存入 MDR：M (MAR) → DB → MDR

​			至此，就获取到了指令需要的操作数。

​		⑤ C~6~、C~7~ 同时有效，打开寄存器 ACC 和 MDR 连接 ALU 的控制门；

​		⑥ 通过 CPU 内部控制线对 ALU 发出 “ADD” 加法指令的控制信号，完成 ACC 和 MDR 内容的相加；

​		⑦ C~8~ 有效，打开 ALU 通往 ACC 的控制门，将计算结果存入 ACC：（ACC）+（MDR）→ （ACC）

​			至此，就完成了加法运算的执行过程。

----

​		还有一些控制信号这条指令没有涉及到：C~9~ 和 C~10~ 分别是控制 PC 的输出和输入的控制信号；C~11~ 和 C~12~ 分别是控制 ACC 的输出和输入的控制信号。

##### 2. 采用 CPU 内部总线

​		类似于系统总线，CPU 内部也可以采用总线方式连接，这种总线也叫做 **片内总线**。片内总线就是 CPU 内部所有部件的公共数据通路，寄存器之间、寄存器与 ALU 之间都由片内总线连接。

​		如果只有一条片内总线，这样的结构称为 **CPU 内部单总线**。这种结构比较简单，硬件容易实现和进行扩展，但存在数据冲突的情况，性能较差。

![](E:\source\jk-english\英语语法初级\图片\5_40_采用CPU内部总线方式的数据通路.png)

​		上图中就是采用了 CPU 内部总线方式（单总线）的数据通路和控制信号。每个寄存器都与总线直接相连，这里同样省略了控制门的符号，用一个小圆圈代替，上面用箭头标出了对应的控制信号。控制信号的下标为 i 表示这是输入端的控制，下标为 o 表示输出端的控制。

​		这里的 ALU 增加了两个寄存器 Y 和 Z，主要是因为 ALU 是组合逻辑电路，本身没有存储数据的功能，运算时必须要求两个输入端同时有效；而单总线上同一时刻（一个时钟周期）只能传送一个数据。因此我们可以设置一个输入寄存器 Y 保存其中一个操作数，让它保持不变，另一个操作数则从总线上获得。同样道理，ALU 的输出也不能直接连接总线输出，否则会影响总线上的输入数据，只能先在输出寄存器 Z 中暂存，等到下个时钟周期再输出。

---

​		接下来我们依然以加法指令 “ADD @ X” 为例，按指令周期的不同阶段来分析 CU 发出的控制信号。

**（1）取指周期**

![](E:\source\jk-english\英语语法初级\图片\5_41_采用CPU内部总线方式的数据通路_取指周期.png)

​		① PC~o~ 和 MAR~i~ 有效，PC 中的内容经内部总线送往 MAR：（PC）→ MAR；

​		② CU 通过控制总线向主存发出读命令（R）：1 → R；

​		③ 主存通过数据总线，将 MAR 中地址所对应存储单元的内容（指令）送至 MDR：M (MAR)  → MDR；

​		④ MDR~o~ 和 IR~i~ 有效，将 MDR 的内容送至 IR：（MDR）→ IR；

​			至此，指令送至 IR，操作码字段交给 CU，就可以进一步产生各种控制信号了。

​		⑤ PC 内容加 1： （PC）+ 1 → PC 

**（2）间址周期**

![](E:\source\jk-english\英语语法初级\图片\5_42_采用CPU内部总线方式的数据通路_间址周期.png)

​		① MDR~o~ 和 MAR~i~ 有效，将指令的形式地址经内部总线送至 MAR：Ad (MDR) → MAR；

​		② CU 通过控制总线向主存发出读命令（R）：1 → R；

​		③ 主存通过数据总线，将 MAR 中地址所对应存储单元的内容（有效地址）送至 MDR：M (MAR)  → MDR；

​			至此，就获取到了指令操作数的有效地址。

**（3）执行周期**

![](E:\source\jk-english\英语语法初级\图片\5_43_采用CPU内部总线方式的数据通路_执行周期.png)

​		① MDR~o~ 和 MAR~i~ 有效，将有效地址经内部总线送至 MAR：（MDR）→ MAR；

​		② CU 通过控制总线向主存发出读命令（R）：1 → R；

​		③ 主存通过数据总线，将 MAR 中地址所对应存储单元的内容（数据）送至 MDR：M (MAR)  → MDR；

​			至此，就获取到了操作数。

​		④ MDR~o~ 和 Y~i~ 有效，将操作数送至寄存器 Y，直接作为 ALU 的一个输入：（MDR）→ Y；

​		⑤ ACC~o~ 和 ALU~i~ 有效，同时 CU 向 ALU 发出 “ADD” 加法指令的控制信号，完成 ACC 和 MDR 内容的相加；得到的结果直接送往寄存器 Z：（ACC）+（Y）→ Z；

​		⑥ Z~o~ 和 ACC~i~ 有效，将运算结果写入 ACC：（Z）→ ACC

​			至此，就完成了加法运算的执行过程。

----

​		现代计算机的 CPU 都集成在一个芯片内，所以采用片内总线的方式可以极大地节省连线，使芯片密度更高、布局更为合理，也更加容易扩展。

​		而为了提升性能，解决单总线结构的数据冲突问题，可以增加总线的数量，这就是 **CPU 内部多总线方式**。这种结构的 CPU 内部有多条公共通路；相比单总线一个时钟内只允许传送一个数据，多总线可以同时传送多个数据，效率更高。

### 5.6 控制器的原理和设计

​		控制单元 CU 控制一条指令执行的过程，实质上就是发出控制信号、依次执行一个微操作序列的过程。很明显，不同的指令中包含的微操作数量不等，每个微操作的复杂程度也不同，所以每条指令的执行时间都是不同的。

​		在 CPU 内，可以通过时钟信号产生节拍，来控制每个微操作的执行。一个指令周期可以包含多个机器周期，每个机器周期又可以包含多个节拍，这样就构成了 **多级时序系统**。

​		控制不同的微操作序列，需要产生不同的时序控制信号。至于如何形成这些控制信号，可以采用不同的时序控制方式，这就被称为 CU 的 **控制方式**。

#### 5.6.1 CU 的控制方式

​		CU 的控制方式，主要有 **同步控制**、**异步控制**、**联合控制** 和 **人工控制** 四种。

##### 1. 同步控制

​		最常见的控制方式就是 **同步控制**。这种方式下 CPU 有一个统一的时钟，所有指令的每一个微操作，执行顺序都是事先确定好的，根据时钟信号在不同的时钟周期依次执行。

​		根据机器周期的不同设置方式，同步控制又有三种不同的方案：

​	**（1）采用定长的机器周期**

​		这是最简单的方式，不论指令对应的微操作有多少、也不管微操作有多复杂，一律采用统一的机器周期来执行各种不同的指令，每个机器周期包含相同的节拍数，每个节拍的宽度完全一致。

![](E:\source\jk-english\英语语法初级\图片\5_8_定长的机器周期.png)

​		这样的话，机器周期的选择必须要以执行最慢的指令和微操作为准，对于比较简单的指令就会有时间上的浪费。

​	**（2）采用不定长的机器周期**

​		采用不定长的机器周期时，每个机器周期内的节拍数可以不等，这样就可以解决微操作执行时间不统一的问题了。

![](E:\source\jk-english\英语语法初级\图片\5_9_不定长的机器周期.png)

​		一般会把大多数微操作安排在一个较短的机器周期内完成，而对于比较复杂的微操作，则通过延长机器周期来解决。

​	**（3）中央控制和局部控制相结合**

​		这种方式相当于是定长和不定长机器周期的结合。将机器的大部分指令安排在统一的机器周期内完成，称为 **中央控制**，这个机器周期一般比较短；而将少数复杂指令中的一些操作，通过插入一些额外的节拍来进行处理，这称为 **局部控制**。

![](E:\source\jk-english\英语语法初级\图片\5_44_中央控制和局部控制结合.png)

​		局部控制的每个节拍跟中央控制的节拍宽度相同，个数则是不确定的。

##### 2. 异步控制

​		异步控制方式不存在统一的时钟信号，没有固定的周期节拍和时钟同步；每条指令和每个微操作耗费的时间都以它们在电路中完成为准。

​		这种控制方式 CPU 没有空闲时间，利用率更高；但微操作的时序就需要有专门的 “应答线路” 来进行控制，结构会更加复杂。

##### 3. 联合控制

​		联合控制方式就是同步控制和异步控制的结合。这种方式下，对于指令中大部分一致的微操作，采用同步控制；而对于小部分特殊的、时间难以确定的操作，则采用异步控制。

##### 4. 人工控制

​		为了调试机器和软件开发的需要，可以在机器面板或者内部设置一些开关或者按键，由人工进行操作控制。例如，一些机器设有 Reset（复位）键，可以人工恢复初始状态。

----

​		确定了 CU 的控制方式，就可以设计具体的控制单元了。根据产生微操作控制信号的方式不同，控制器又可以分为 **组合逻辑控制器** 和 **微程序控制器**。

#### 5.6.1 组合逻辑控制器

​		组合逻辑控制器直接通过组合逻辑电路的设计，根据当前的指令操作码、工作周期标志以及时钟信号生成对应的控制信号（微操作）序列，实现控制器的各种功能。也叫做 **硬布线控制器**。

##### 1. 基本原理和结构框图

​		组合逻辑控制器的控制信号，都是由控制单元（CU）产生的。它的输入是时钟信号、操作码译码之后的信号以及条件码标志位。

![](E:\source\jk-english\英语语法初级\图片\5_45_CU输入输出框图.png)

​		存放在 IR 中的 n 位操作码可以经过一个译码器，产生 2^n^ 个输出；于是每种操作码都会对应一个输出信号送至 CU。

​		CU 的时钟信号就是一个脉冲序列，让它通过一个节拍发生器（计数器）就可以产生一个宽度等于时钟周期的节拍序列。在每个节拍内，可以保证完成一次微操作，数据信息能够完成数据通路中的流动。这样，CU 就可以按照节拍来发出控制信号的序列了。

##### 2. 微操作的节拍安排

​		接下来就可以将每个工作周期中的微操作，安排到对应的节拍中了。

​		安排微操作的节拍应该遵循以下基本原则：

​		① 微操作的先后顺序不能发生改变；

​		② 如果是控制不同部件的微操作，可以同时执行的话，应该尽可能安排在同一个节拍内；

​		③ 如果有些微操作耗时不长，那可以将多个这样的微操作安排在一个节拍内完成，并且允许它们有先后次序。

​		现在我们假设采用定长机器周期的同步控制方式，每个机器周期包含 3 个节拍。以上一节讨论的 10 条不同指令为例，可以安排微操作的节拍如下：

**（1）取指周期**

![](E:\source\jk-english\英语语法初级\图片\5_46_取指周期节拍安排.png)

**（2）间址周期**

![](E:\source\jk-english\英语语法初级\图片\5_47_间址周期节拍安排.png)

**（3）执行周期**

​		同样，还是针对不同类型的指令，分别分析微操作的节拍安排。

​		**1）非访存指令**

​		非访存指令一般都只有很简单的操作，因此可以直接把微操作安排在一个节拍内。可以选择 T~0~ ~ T~2~ 的任一节拍，其余节拍空闲。

​		这里以 CLA 指令为例，把它的微操作安排在 T~2~ 节拍内：

<img src="C:/Users/18133/Desktop/课件/pictures/5_48_执行周期节拍安排_非访存.png" style="zoom:80%;" />

​		**2）访存指令**

​		访存指令中需要进行访问主存操作，微操作的节拍安排可以跟取指、间址周期类似。

![](E:\source\jk-english\英语语法初级\图片\5_49_执行周期节拍安排_访存.png)

​		**3）转移指令**

​		同样，转移指令微操作比较简单，可以在 T~0~ ~ T~2~ 任选一个节拍进行安排。

![](E:\source\jk-english\英语语法初级\图片\5_50_执行周期节拍安排_转移.png)

**（4）中断周期**

​		在指令周期的最后阶段，CPU 会向所有中断源发出中断查询信号，若检测到有中断请求，在允许中断的条件下就会进入中断周期。中断周期的微操作节拍安排如下：

![](E:\source\jk-english\英语语法初级\图片\5_51_中断周期节拍安排.png)

##### 3. 组合逻辑设计

​		安排好了指令微操作的节拍，接下来就可以设计组合逻辑电路，产生需要的控制信号了。

​		组合逻辑设计主要由三步来完成：列出所有微操作命令的操作时间表；写出每一个微操作对应控制信号的逻辑表达式；根据逻辑表达式画出组合逻辑电路图。

**（1）列出微操作命令的操作时间表**

​		根据微操作的节拍安排，可以将所有指令中每个工作周期、每个节拍需要做的微操作全部列出来，这就是 **操作时间表**。下表中列出了我们当前所考虑的 10 条指令，如果某条指令需要执行某个微操作，那么对应的格子填 “1”。

![](E:\source\jk-english\英语语法初级\图片\5_52_操作时间表.png)

​		这样，我们就知道了对于某一条指令，在某个节拍内需要给出什么样的控制信号。

**（2）写出微操作的逻辑表达式**

​		根据操作时间表，可以对每个微操作控制信号进行真值判断，得到微操作命令的初始逻辑表达式。经过化简就可以得到最简逻辑表达式，从而可以通过电路进行实现。

​		例如，对于微操作 M（MAR）→ MDR，逻辑表达式为：
$$
\begin{align*}
&M(MAR) → MDR
\newline &= FE\cdot T_1 \,+ IND\cdot T_1 \,(ADD+STA+LDA+JMP+BAN) \,+\,EX\cdot T_1(ADD+LDA)
\newline &= T_1 \, \{\, FE\, +\, IND \, (ADD+STA+LDA+JMP+BAN) \, + EX \, (ADD+LDA)\, \}
\end{align*}
$$
​		这里的 FE、IND、EX 是工作周期标志，T~1~ 是节拍，ADD、STA、LDA、JMP、BAN 代表对应指令，来自操作码译码器的输出选择。

**（3）画出微操作命令的逻辑电路图**

​		对于每一个微操作，有了它的逻辑表达式，就可以画出对应的组合逻辑电路图。例如，微操作 M（MAR）→ MDR 的逻辑电路图为：

![](E:\source\jk-english\英语语法初级\图片\5_53_组合逻辑电路图.png)

​		组合逻辑控制器的特点是纯硬件电路实现，因此速度更快、性能更好；设计起来思路清晰、简单明了。但是由于每个微操作命令都对应着一套逻辑电路，因此结构比较复杂，也不够规范；而且逻辑线路是固定的，不易扩展和修改。

​		组合逻辑控制器通常应用在 RISC 架构中。

#### 5.6.2 微程序控制器

​		组合逻辑控制器线路庞杂，为了克服这个缺点，可以采用类似 “存储程序” 的方法，来形成具体的微操作序列；这被叫做 “**微程序**”，采用这种技术的控制器就被称为 **微程序控制器**。

##### 1. 基本原理和结构框图

​		微程序控制器的基本思想是，将每条机器指令编写成一个 **微程序**，每一个微程序包含若干条 **微指令**，每一条微指令对应一个或几个微操作命令。然后把这些微程序存入一个 **控制存储器**（简称控存，CM）中，用读取指令的方式将它们读出依次执行就可以了。

![](E:\source\jk-english\英语语法初级\图片\5_54_机器指令对应的微程序.png)

​		这样，每一条机器指令都可以对应着一个微程序。对于取指、间址、中断周期，所有指令的操作都是相同的，因此可以统一编制成一个微程序；而每条指令执行阶段的操作则单独对应一个微程序。这样，控制存储器中微程序的个数，就是机器指令的数量，再加上对应取指、间址、中断周期的 3 个微程序。

​		微指令的基本格式，应该包含两个字段，前面是操作控制字段，对应着微操作命令，可以发出各种控制信号；后面是顺序控制字段，可以指出下条微指令的地址（简称 **下地址**），从而控制微指令序列的顺序执行。

![](E:\source\jk-english\英语语法初级\图片\5_55_微指令格式.png)

​		微程序控制单元的结构如下所示：

![](E:\source\jk-english\英语语法初级\图片\5_56_微程序控制单元结构框图.png)

- 控制存储器：微程序控制单元的核心部件，存放着全部的微程序；显然控存可以采用 ROM 实现。
- CMAR：控存地址寄存器，用来存放准备读取的微指令地址；
- CMDR：控存数据寄存器，用来存放从控存读出的指令；
- 顺序逻辑：用来形成下一条微指令的地址，用来控制微指令序列的执行顺序。

##### 2. 微程序控制器的工作过程

​		我们可以结合一个具体的例子，来说明微程序控制器的工作过程。假设一段用户程序，有下面的两条汇编指令：

```
  LDA  X
  ADD  Y
  ...
```

​		当执行到第一条指令 LDA X 时，PC 的值为这条指令在主存中存放的地址。控制单元 CU 将执行以下的操作。

​	**（1）取指阶段**

​		首先进入取指周期，微程序控制单元将执行取指阶段的每一个微操作。

![](E:\source\jk-english\英语语法初级\图片\5_57_微程序控制单元工作过程_取指阶段.png)

​		① 将取指周期的微程序首地址 M 送至 CMAR：M → CMAR；

​		② 取微指令，将控存 M 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；

​		③ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 (PC) → MAR，1 → R；

​		④ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 M + 1，所以将 M + 1 送至 CMAR：Ad (CMDR) → CMAR；

​		⑤ 取下一条微指令，将控存 M + 1 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；

​		⑥ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 M (MAR) → MDR，（PC）+ 1 → PC；

​		⑦ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 M + 2，所以将 M + 2 送至 CMAR：Ad (CMDR) → CMAR；

​		⑧ 取下一条微指令，将控存 M + 2 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；

​		⑨ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 （MDR）→ IR，

OP (IR) → CU。

​		至此，第一条指令 “LDA X” 已经取出并保存到了 IR 中。

​	**（2）执行阶段**

​		简单起见，我们假设这条指令采用了直接寻址，因此跳过间址周期，直接进入执行周期。

![](E:\source\jk-english\英语语法初级\图片\5_58_微程序控制单元工作过程_执行阶段.png)

​		① 根据指令的操作码，形成取数指令的微程序首地址 Q，并送至 CMAR：OP (IR) → 微地址形成部件 → CMAR；

​		② 取微指令，将控存 Q 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；

​		③ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 Ad (IR) → MAR，1 → R；

​		④ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 Q + 1，所以将 Q + 1 送至 CMAR：Ad (CMDR) → CMAR；

​		⑤ 取下一条微指令，将控存 Q + 1 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；

​		⑥ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 M (MAR) → MDR；

​		⑦ 形成下一条微指令的地址。当前微指令的顺序控制字段指出了下地址为 Q + 2，所以将 Q + 2 送至 CMAR：Ad (CMDR) → CMAR；

​		⑧ 取下一条微指令，将控存 Q + 2 地址单元中的微指令取出，送至 CMDR：CM (CMAR) → CMDR；

​		⑨ 产生微操作命令，微指令的操作控制字段中为 “1” 的各位发出控制信号，执行微操作 （MDR）→ ACC。

​		至此，就完成了取数指令 LDA X 的全部操作。

​		最后一条微指令的顺序控制字段为 M，所以接下来 CPU 又将进入下一条指令 ADD Y 的取指周期，从控存中依次读出微程序的每条微指令、发出一系列的控制信号。

​		微程序控制单元设计的过程中，关键问题是微指令的操作控制字段怎样去发出控制信号，以及如何具体产生下一条微指令的地址。这跟 **微指令的编码方式** 和 **微地址的形成方式** 有关。

##### 3. 微指令的编码方式

​		微指令的编码方式，主要是指怎样对微指令的操作控制字段进行编码，进而发出对应的控制信号。所以也称为 **微指令的控制方式**。

​		微指令的编码方式主要有以下几种。

​	**（1）直接编码（直接控制）**

​		最简单的方案，就是让微指令的操作控制字段中，每一位都对应着一个微操作命令；这种编码方式就称为 **直接编码方式**。

​								![](E:\source\jk-english\英语语法初级\图片\5_59_微指令的编码方式_直接编码.png)

​		当控制字段的某位为 “1” 时，就表示控制信号有效，进而打开对应数据通路的控制门；为 “0” 时则表示控制信号无效，控制门关闭。

​		这种方式实现简单、含义清晰，而且只要微指令从控存中读取出来就立刻可以发出对应的控制信号，速度非常快。不过由于微操作数量众多，因此控制字段的位数也会非常多，可能达到几百位，造成控存容量过大。

​	**（2）字段直接编码**

​		想要减少控制字段的位数，可以通过加一个译码器来解决。不过由于可能会有多个微操作命令同时有效（并行）的情况，因此可以根据并行发出的微命令个数将控制字段再做 “分段”，每段内分别进行译码、对应一个微操作命令。

​		这种方式由字段直接译码发出微命令，所以叫做 **字段直接编码方式**，也称为 **显式编码**。

![](E:\source\jk-english\英语语法初级\图片\5_60_微指令的编码方式_字段直接编码.png)

​		这里所谓的 “**微命令**” 就是 CU 发出的控制信号，而 “**微操作**” 就是微命令生效后执行的过程，它们是一一对应的关系，所以一般我们不再过多区分。

​		指令执行过程中，有一些微命令可以同时产生，我们称它们是 “**相容**” 的；而如果一组微命令不能同时发生，则称它们是 “**互斥**” 的。字段直接编码时，应该将互斥的一组微命令放在一个字段内；而不同字段的微命令，则是相容的。每个字段的长度可以不同。此外，每个字段还应该留出一种状态，表示不发出这一组中的任何微命令。

-------

​		例如，某机器的微指令格式中，有 8 个控制字段，每个字段可以分别发出 5、8、3、16、1、7、25、4 种控制信号。那么采用直接编码和字段直接编码方式设计微指令，需要的操作控制字段至少是多少位？

​	（1）直接编码

​		微指令操作控制字段的位数，就是总的控制信号数：
$$
5+8+3+16+1+7+25+4=69
$$
​	（2）字段直接编码

​		每个字段需要保留一个编码，表示不做任何操作；因此 8 个字段分别需要表示 6、9、4、17、2、8、26、5 种情况。对应的编码位数应该是：3、4、2、5、1、3、5、3，因此总位数为：
$$
3+4+2+5+1+3+5+3=26
$$
​		很明显，使用字段直接编码可以有效地减少控制字段的位数。

------

​	**（3）字段间接编码**

​		这种方式在字段直接编码的基础上，又增加了一步转换，即一个字段的某些微命令，还需要受到另一字段译码输出的控制，因此被称为 **字段间接编码**，也叫 **隐式编码**。

![](E:\source\jk-english\英语语法初级\图片\5_61_微指令的编码方式_字段间接编码.png)

​		这种方式可以进一步减少控制字段位数，但电路更加复杂、而且削弱了微指令的并行控制能力，因此一般只是作为字段直接编码的辅助手段。

​	**（4）混合编码**

​		将直接编码和字段编码（直接或者间接）混合使用，就成了 **混合编码方式**。这种方式主要是综合考虑微指令字长、灵活性和执行速度各方面的要求。

##### 4. 微指令格式

​		微指令的格式跟微指令的编码方式有关，通常可以分为水平型微指令和垂直型微指令。

​	**（1）水平型微指令**

​		水平型微指令的主要特点，就是一次能定义并执行多个并行操作的微命令。从编码方式看，前面介绍的直接编码、字段直接编码、字段间接编码以及混合编码都属于水平型微指令。

​	**（2）垂直型微指令**

​		垂直型微指令不强调并行控制的功能，而是采用了类似机器指令中操作码的方式，在操作控制字段中用 “**微操作码**” 来规定微指令的功能。通常一条微指令中，只有 1 ~ 2 个微命令，控制 1 ~ 2 种操作。

![](E:\source\jk-english\英语语法初级\图片\5_62_微指令格式.png)

​		相比而言，水平型微指令并行操作能力更强、速度更快、效率更高、灵活性强；而垂直型微指令与机器指令更加类似，语义更加清晰。水平型微指令用较长的微指令结构，换取较短的微程序；而垂直型微指令是以较长的微程序结构，换取较短的微指令结构。

##### 5. 微指令序列地址的形成

​		微指令执行过程中，在不同阶段，需要采用不同的方式形成后续微指令的地址。

​	**（1）直接由当前微指令的下地址字段给出**

​		大部分微指令都会在下地址字段直接指出下一条微指令的地址，在每一段微程序内部一般都是这种方式。也被称为 **断定方式**。

​	**（2）根据指令的操作码形成**

​		 取指周期结束、机器指令被存放入 IR 后，接下来执行阶段微指令的地址，会由微地址形成部件根据操作码产生。

​		所谓的微地址形成部件，其实也就是一个编码器，它的输入是指令操作码，输出是对应微程序执行阶段的首地址。它可以用 PROM 来实现，以指令的操作码作为 PROM 的地址，相应的存储单元存放微程序首地址。

​		对于不同的方式，可以用一个 **多路选择器**，通过对当前一些状态标志的判断来进行选择。

![](E:\source\jk-english\英语语法初级\图片\5_63_微指令后续地址的形成.png)

​		除了上面最基本的两种方式，还可以采用以下方法形成微指令序列地址。

​	**（3）增量计数器法**

​		可以发现，大多数情况下后续微指令的地址都是连续的，所以可以借鉴 PC 的功能，采用 “增量计数法” 形成后续微指令的地址：(CMAR) + 1 → CMAR。

​	**（4）分支转移**

​		当遇到转移指令时，微指令也会出现分支，这时必须根据转移方式指明的判别条件，根据各种标志决定下一条微指令的地址。

​	**（5）通过测试网络形成**

​		这种方式微指令的地址码分两部分，高段为非测试地址，需要直接保留；低段则为测试地址，需要结合测试源的信号、通过测试网络来生成。

​	**（6）由硬件生成微程序入口地址**

​		电源接电后，程序第一条微指令的地址（入口地址），可以由专门的硬件电路产生。

​		另外，当有中断请求且条件满足时，CPU 进入中断周期，这时也可以由硬件产生中断周期微程序的入口地址。同理，当有间接寻址时，也可以由硬件产生间址周期微程序的入口地址。

##### 6. 微程序设计

​		设计微程序控制器，主要任务其实就是编写各条指令的微程序。

​		具体步骤也可以分为三步：首先写出所有指令的全部微操作以及节拍安排；其次确定微指令格式；最后编写出每条微指令的二进制代码（称为 **微指令码点**）。

​	**（1）写出机器指令的微操作以及节拍安排**

​		这里我们用跟组合逻辑设计相同的案例，只考虑 10 条机器指令。简单起见，我们这里不考虑间接寻址和中断的情况，只讨论取指和执行周期。

​		**1）取指阶段**

​		跟组合逻辑设计类似，取指阶段的微操作可以安排在三个节拍内：

![](E:\source\jk-english\英语语法初级\图片\5_64_微程序设计_取指阶段1.png)

​		如果一个节拍内的微操作，都对应一条微指令，那么上面的取指微程序对应着 3 条微指令。

​		不过我们发现，微程序控制器的所有控制信号都来自于微指令，而微指令都存放在控制存储器中。所以每条微指令执行之前，必须有一个将微指令地址送至 CMAR 的过程。或者说，每条微指令执行结束，应该形成后续地址，交给 CMAR；这必须额外耗费一个时钟周期（节拍）。

![](E:\source\jk-english\英语语法初级\图片\5_65_微程序设计_取指阶段2.png)

​		这样，取指操作就需要 6 条微指令来完成。所有微指令都会由时钟信号的上升沿打入 CMDR 中。

​		**2）执行阶段**

​		同样，执行阶段的微操作是由指令操作码决定的；每条微指令完成之后同样要考虑后续指令地址的形成。

​		**a）非访存指令**

![](E:\source\jk-english\英语语法初级\图片\5_66_微程序设计_执行阶段1_非访存.png)

​		**b）访存指令**

<img src="C:/Users/18133/Desktop/课件/pictures/5_67_微程序设计_执行阶段2_访存.png" style="zoom: 55%;" />

​		**c）转移指令**

![](E:\source\jk-english\英语语法初级\图片\5_68_微程序设计_执行阶段3_转移.png)

​		以上总共有微指令 38 条，不同的微操作有 20 个。

​	**（2）确定微指令格式**

​		确定微指令格式，主要是确定微指令的编码方式、后续微指令地址的形成方式，以及微指令字长 3 个方面。

- 微指令编码方式：微操作不多，可以采用直接编码方式；
- 后续地址形成方式：根据指令操作码和微指令的下地址，确定后续微指令地址的形成；
- 微指令字长：20 个微操作，对应 20 位操作控制字段；38 条微指令，需要 6 位下地址字段。微指令字长至少取 26 位。

​		进一步分析可以发现，38 条微指令中，19 条都是将后续地址送入 CMAR 的操作。这不仅在微指令上有所浪费，而且相当于每两个时钟周期，才能取出并执行一条微指令。

​		我们可以将 CMDR 的下地址字段 Ad (CMDR) 直接接到控制存储器的地址线上，在下一个时钟信号的上升沿，就将对应地址的内容（下一条微指令）读取到 CMDR 中。这样就省去了 CMAR，直接用 Ad (CMDR) 取代，而且做到了每一个时钟周期完成一条微指令，大大提升了运行速度。

​		同样，指令操作码 OP (IR) 通过微地址形成部件产生的后续地址，也可以直接送到控制存储器的地址线上。

![](E:\source\jk-english\英语语法初级\图片\5_69_微程序设计_省去CMAR的控制单元.png)

​		通过这样的化简，我们就省去了 19 条微指令，并同时省去了 Ad (CMDR) → CMAR 和 OP (IR) → 微地址形成部件 → CMAR 两个微操作。于是总共只需要 38 - 19 = 19 条微指令和 20 - 2 = 18 个微操作。

​		这样，最少只需要 18 位控制字段和  5 位地址字段。不过为了便于以后扩展，我们可以取 24 位操作控制字段和 6 位下地址字段。微指令格式如下：

![](E:\source\jk-english\英语语法初级\图片\5_70_微程序设计_微指令格式.png)

​		操作控制字段的第 0 ~ 17 位分别控制的微操作为：

​								<img src="C:/Users/18133/Desktop/课件/pictures/5_71_微程序设计_微指令控制字段对应的微操作.png" style="zoom: 60%;" />	

​	**（3）编写微程序码点**

​		根据每条微指令的操作控制字段和下地址，就可以得到每一条微指令对应的二进制代码（码点）了。这里我们省略了码点中所有的 0。

![](E:\source\jk-english\英语语法初级\图片\5_72_微程序设计_微指令码点.png)

##### 7. 其它微程序设计技术

​		微程序控制器中，控制信号是以二进制代码的形式出现，因此不需要像组合逻辑那样考虑逻辑表达式的化简，因此设计更加简便，更容易调试和修改。当然，由于执行每个微操作都要访问控制存储器，所以对控制存储器的速度要求较高。微程序控制器通常应用在 CISC 架构中，目前大多数计算机都会采用微程序设计技术。

​		微程序设计技术也可以有其它一些方式的扩展。

​	**（1）静态微程序设计**

​		通常指令系统是固定的，对应每一条机器指令的微程序，都是计算机的设计者预先编写好的，这种微程序设计技术称为 **静态微程序设计**，其控制存储器一般采用 ROM。

​	**（2）动态微程序设计**

​		如果可以通过改变微指令和微程序，来改变机器的指令系统，这种微程序设计技术称为 **动态微程序设计**。这种方式可以在一台机器上实现不同类型的指令系统，有利于仿真和研究测试，其控制存储器需要采用 EPROM。

​	**（3）毫微程序设计**

​		如果采用两级微程序的设计方法，用第一级微程序来解释机器指令，再用第二级微程序（称为 “**毫微程序**”）来解释第一级微程序，这样的设计方式就称为 **毫微程序设计**。组成毫微程序的 **毫微指令** 是用来解释微指令的。

​		采用毫微程序设计计算机的优点是，可以用更少的控制存储器空间来达到高度的并行；不过同时运行速度会受到一定程度的影响。

### 5.7 中断和异常

#### 5.7.1 基本概念和分类

​		计算机在执行程序的过程中，有时会遇到一些异常情况或者特殊请求；这时就需要计算机暂停正在运行的程序，转而先去处理这些异常或特殊请求，处理结束之后再返回程序的断点处继续执行。这种处理方式就被称为 “**中断**”，计算机的这种功能就称为 **中断处理**；实现这种功能所需的软硬件技术统称为 **中断技术**。

​		很显然，对于一些突发情况和实时传来的外部信号，相比时刻查询的方式，使用中断技术可以大大地提高计算机的整体效率。

​				<img src="C:/Users/18133/Desktop/课件/pictures/5_73_查询_刷手机.png" style="zoom:50%;" />					<img src="C:/Users/18133/Desktop/课件/pictures/5_74_中断_打电话.png" style="zoom:50%;" />

​		能够引发中断的因素有很多，比如电源掉电、打印机请求、运算溢出、缺页等等。通常将能够引起中断的各种因素称为 **中断源**。根据各种中断源的类型，可以对中断进行不同的分类。

##### 1. 中断和异常

​		从中断的来源看，直观上可以分成两类：一类是由外部设备向 CPU 发出的请求（比如打印），或者突发的外部事件或环境对计算机造成了影响（比如电源掉电），在 CPU 外部产生；另一类是 CPU 在执行指令时遇到的异常情况，在 CPU 内部产生。

​		通常将 CPU 内部产生的中断称为 **异常（Exception）**，也称作 **内中断**。异常一般是 CPU 的控制单元（CU）在执行指令时遇到了意外情况、因而必须暂停处理；由于一定会在一条指令执行结束后才发出中断，因此也被叫做 **同步中断**。

​		与之对应，来自于 CPU 外部其它硬件设备的中断，就被称为 **外中断**，或者直接叫做（狭义的） **中断（Interrupt）**。它们通常是外部设备依照 CPU 时钟随机产生的，因此也被叫做 **异步中断**。

![](E:\source\jk-english\英语语法初级\图片\5_75_中断和异常.png)

​		事实上，对于中断（狭义）和异常，CPU 的处理流程都是先中止当前正在执行的程序、转而去执行相应的中断处理程序（称为 “**中断服务程序**”），完成中断响应之后，再回到断点处继续执行。因此，一般可以把它们统称为（广义的）**中断**。

##### 2. 中断和异常的分类

​		中断请求并不一定都非常急迫、必须立刻响应。CPU 可以对中断进行判别、选择，屏蔽某些中断源的请求；根据是否可以被屏蔽，中断（狭义）又可以分成两类：

- **可屏蔽中断**：可屏蔽中断有 “屏蔽” 和 “非屏蔽” 两种状态；处在屏蔽状态的中断，CPU 将不予以响应。I/O 设备的中断请求都属于可屏蔽中断。

- **不可屏蔽中断**：一些急迫事件 CPU 必须予以响应，发出的中断不能屏蔽。例如电源掉电就属于不可屏蔽中断。

  ![](E:\source\jk-english\英语语法初级\图片\5_76_中断和异常的分类.png)

​		而对于异常，由于它跟指令的执行有关，因此根据中断处理完成后、接下来指令执行的情况，可以进一步进行分类：

- **故障（Fault）**：通常可以纠正，一旦纠正则程序可以重新执行原先产生中断的那条指令；也称为 “程序性事故”。例如运算溢出、缺页异常。
- **陷阱（Trap）**：这种异常是人为设置的，表示自愿停止现行程序、转入中断处理，因此也叫 “自愿中断”、“自陷”。一般计算机中都会设置陷阱指令，执行到它就会转至别处做特殊处理，完成之后就返回到陷阱指令的下一条指令继续执行。例如调试程序时的断点设置、执行系统调用等。
- **异常中止（Abort）**：如果发生了严重的错误，程序无法继续执行，那么就只能把控制权交给异常中止处理程序；而现行程序只能强制停止运行。例如硬件故障、系统表中无效的值等。

##### 3. 中断系统

​		中断改变了计算机执行程序的顺序，因此需要 CPU 进行特别的处理。为了实现中断处理的功能，CPU 中一般会设置专门的处理机构，这就是 **中断系统**。

​		中断系统主要需要解决以下一些问题：

- 中断源怎样向 CPU 发出中断请求；

- 当有多个中断源同时发出请求时，怎样确定响应顺序；

- CPU 怎样响应中断请求；

- CPU 响应中断之后，怎样保护现场；

- CPU 响应中断后，怎样暂停原程序的执行、找到中断服务程序的入口地址；

- 中断处理结束后，CPU 如何恢复现场、返回原程序的断点处；

- 如果中断处理时又有新的中断请求，应该怎样处理。

  接下来我们就通过学习中断系统，来解决这些问题。

#### 5.7.2 中断的检测

​		在 CPU 的指令周期中，最后一个阶段就是 **中断周期**。在一条指令执行阶段的最后时刻，CPU 会发出 **中断查询信号**，检测是否有中断请求。如果有，则进入中断周期进行中断处理。

##### 1. 中断请求标记

​		不同的中断源都可以向 CPU 发出中断请求，为了区分中断源，中断系统中会专门设置一个 **中断请求标记触发器**，简称 **中断请求触发器**，用 **INTR** 表示。当某个中断源的触发器 INTR~i~ 为 “1” 时，就表示该中断源发来了请求。

​		这些触发器可以分散在各个中断源的接口电路中，也可以集成在 CPU 中，组成一个 **中断请求标记寄存器**。

​											![](E:\source\jk-english\英语语法初级\图片\5_77_中断请求标记寄存器.png)

​		寄存器里的每一位就对应着一个中断源的请求触发器。任意一个触发器为 1，就表示对应的中断源发出了中断请求。

##### 2. 中断判优

​		在中断系统中，同一时刻只能响应一个中断源的请求。如果有多个中断源同时发出了请求，那就需要中断系统按照设定好的优先顺序来依次响应；这被称为 **中断判优**。中断源的优先级是依据重要性和急迫性而定的。

​		中断判优就是要对一组中断请求按优先级进行 “排队”，可以用硬件和软件两种方式实现。

​	**（1）硬件排队**

​		硬件排队是直接用硬件电路实现中断请求的排队，具体方法很多，主要有两种：一种是在 CPU 内统一设置一个 “排队器”；另一种是在中断源设备的接口电路中分别设置排队器。

<img src="C:/Users/18133/Desktop/课件/pictures/5_78_集成在CPU中的排队器.png" style="zoom:90%;" />

- 在 CPU 内设置排队器：各中断源的请求触发器按优先级依次排列，高优先级的请求信号通过接入一个多输入的与非门，来 “封住” 低优先级的中断请求。

![](E:\source\jk-english\英语语法初级\图片\5_79_链式排队器.png)

- 在接口电路中设置排队器：每个接口电路中都设置一个反相器和一个与非门，与非门的输出接入下一级，就可以实现对更低优先级中断请求的封锁。它们彼此之间直接连成链状，因此也称为 “**链式排队器**”。

​	**（2）软件排队**

​		软件排队，就是直接通过编写查询程序实现中断请求的排队。

![](E:\source\jk-english\英语语法初级\图片\5_80_软件排队.png)

​		程序按照中断源的优先级，从高到低依次判断是否有中断请求，这样就保证了中断响应的顺序。

#### 5.7.3 中断的响应

##### 1. 中断响应的条件

​		由于在处理中断时，CPU 不应受到新中断请求的打扰，因此需要有 “开关中断” 的功能。在中断系统中，这是由 **允许中断触发器 EINT** 和专门的指令来实现的。

​		EINT 可以被 **开中断指令** 置 “1”，这时表示 CPU 打开了中断功能，允许响应中断源的请求；EINT 也可以被 **关中断指令** 置 “0”，这意味着 CPU 关闭中断功能，禁止响应中断。

​		在 x86 架构的 CPU 中，EINT 就对应着 **标志寄存器**（程序状态字）**efl** 中的一位，用 **IF** 表示。

![](E:\source\jk-english\英语语法初级\图片\5_81_x86架构标志寄存器efl.png)

​		因此可以总结，当 EINT = 1 且有中断请求（INTR~i~ = 1）时，CPU 就可以响应中断。

##### 2. 中断响应的时间

​		很多情况下中断请求的产生是随机的，为了不影响 CPU 的正常工作，需要周期性地在统一的时刻由 CPU 发出中断查询信号，判断当前是否有中断请求。

<img src="C:/Users/18133/Desktop/课件/pictures/5_82_CPU发出中断查询信号.png" style="zoom:80%;" />

​		因此 CPU 响应中断的时间，一定是在每条指令执行阶段的结束时刻；相当于在指令周期最后又加入了一个阶段，这就是 **中断周期**。执行周期结束后，如果有中断请求，则 CPU 进入中断周期；如果没有则直接进入下一条指令的取指周期。

##### 3. 中断响应的过程

​		CPU 响应中断之后，就会进入中断周期。在中断周期 CPU 会执行一系列的操作，这些操作都是由一条 **中断隐指令** 完成的。所谓的隐指令，指的是指令系统中本身没有这条指令，它是由硬件自动完成的。具体操作如下：

​	**（1）保护程序断点**

​		将当前 PC 的内容（程序断点位置）保存到主存中。可以存入特定的某个地址（比如 0 地址），也可以存入堆栈中。

​	**（2）寻找中断服务程序的入口地址**

​		在中断周期内，可以用两种方法寻找中断服务程序的入口地址：硬件向量法和软件查询法，分别对应着硬件和软件实现。

​	**（3）关中断**

​		为了在响应中断后，不受到新的中断请求的干扰，在中断周期需要自动做 “关中断” 的操作，禁止 CPU 再次响应中断请求。关中断的具体操作就是将允许中断触发器 EINT 置 “0”，一般直接由硬件电路实现。

​		对应的微操作如下：

![](E:\source\jk-english\英语语法初级\图片\5_35_中断周期微操作.png)

#### 5.7.4 中断服务程序

##### 1. 中断服务程序的入口地址

​		不同的中断请求，需要执行不同的中断服务程序。寻找中断服务程序的入口地址，通常可以采用两种方法：**硬件向量法** 和 **软件查询法**。

​	**（1）硬件向量法**

​		所谓硬件向量法，就是使用硬件直接产生一个 **向量地址**，再用这个向量地址找到中断服务程序的入口地址。向量地址由中断向量地址形成部件产生。

​		中断向量地址形成部件的输入，是来自排队器的输出 INTP~i~ ，它的输出则是一个二进制的 **中断向量**。一般可以让一个中断源对应一个向量地址，因此这个部件本质上就是一个编码器。

![](E:\source\jk-english\英语语法初级\图片\5_83_中断向量地址形成部件.png)

​		通过向量地址寻找中断服务程序入口地址可以采用两种方法。

![](E:\source\jk-english\英语语法初级\图片\5_84_通过向量地址寻找入口地址.png)

- 在向量地址对应内存单元放一条 **无条件转移指令**。这样 CPU 响应中断时，只要将向量地址交给 PC，然后执行这条指令，就可以跳转到中断服务程序入口地址了。
- 设置 **向量地址表**。向量地址表存放在主存中，向量地址就是对应存储单元的地址，而存放的内容就是中断服务程序的入口地址。

​		硬件向量法寻找入口地址速度快，现代计算机中普遍使用这种方法。

​	**（2）软件查询法**

​		用软件寻找中断服务程序入口地址的方法，就叫做软件查询法。各个中断源对应的入口地址，是由程序员（或系统）预先定好、写入程序的；可以结合软件排队的中断判优，确定要响应某个中断请求时，直接跟上一条转移指令、跳转至定义好的入口地址就可以了。

​		软件查询法不涉及硬件，更加容易维护和扩展，但查询的时间更长。

##### 2. 中断服务程序的流程

​		不同的中断请求对应的中断服务程序不同，不过它们的处理流程是类似的，一般包括 **保护现场**、**中断服务**、**恢复现场** 和 **中断返回** 4 个部分。

​	**（1）保护现场**

​		保护现场通常包含两层含义：一是保存程序的断点，这由中断隐指令完成；二是保存通用寄存器和状态寄存器的内容，这需要中断服务程序完成。

​		具体操作就是在中断服务程序的起始部分，安排几条存数（Store）指令，将寄存器的内容全部保存到主存中；或者直接用入栈（Push）指令将寄存器内容推入栈中。

​	**（2）中断服务**

​		中断服务是中断服务程序的主体部分，针对不同的中断源，需要做出对应的操作内容。

​	**（3）恢复现场**

​		中断服务程序的结尾部分，还需要恢复现场。对应着之前的保护现场，这一步可以用取数（Load）指令或者出栈（Pop）指令，将保存在主存中的信息恢复到寄存器中。

​	**（4）中断返回**

​		中断服务程序的最后一条指令，通常是一条 **中断返回指令**，从而返回到原程序的断点处继续执行。

![](E:\source\jk-english\英语语法初级\图片\5_85_中断流程（单重多重中断）.png)

​		如果在 CPU 执行中断服务程序时，又来了一个新的中断请求，这时有两种处理方式：一种是直接不予响应，即 CPU 在响应中断的过程中保持 “关中断” 状态，直到中断服务程序执行结束、返回之前才开中断；另一种则是 CPU 立即响应新的中断请求，这需要在中断服务程序的开始阶段 “开中断”。 

#### 5.7.5 中断屏蔽技术

##### 1. 多重中断

​		如果 CPU 在响应某个中断请求的时候，另一个中断源又提出了一个新的中断请求；而 CPU 立即响应这个请求，暂停正在运行的中断服务程序、转而去运行新的中断服务程序，这就是 **中断嵌套**，也称为 **多重中断**。 与之对应，如果 CPU 在响应中断时不去响应新的中断请求，则称为 **单重中断**。

![](E:\source\jk-english\英语语法初级\图片\5_86_多重中断.png)

​		实现多重中断，需要满足两个基本条件：

- 提前设置 “开中断” 指令

​		由于进入中断周期后，中断隐指令会自动将 EINT 置为 0，因此默认会关中断、不再响应新的中断请求；这时如果希望处理多重中断，就必须在中断服务程序的开始阶段设置 “开中断” 指令来打开中断。

- 优先级高的中断源有权中断优先级低的中断源

​		只有优先级别更高的中断源，才能打断正在执行的中断服务程序、优先被响应。

-----

​		例如，有 A、B、C、D 四个不同的中断源，优先级为 A > B > C > D。在 CPU 执行程序时，在某个指令周期，同时查询到了 B、C 发来的中断请求；之后在执行中断服务程序的过程中，又先后查询到了 D、A 的请求。那么如果允许多重中断，中断处理的时间顺序如下：

![](E:\source\jk-english\英语语法初级\图片\5_87_多重中断的响应顺序.png)

-----

​		中断请求如果同时到来（比如上例中的 B、C），我们可以进行中断判优、利用排队器决定它们的先后顺序。但对于多重循环，还需要在中断响应过程中继续判断优先级、决定是否可以打断当前的中断服务程序。这是通过 **中断屏蔽技术** 来实现的。

##### 2. 中断屏蔽触发器

​		为了实现对每个中断源的屏蔽，可以在中断请求触发器 INTR 之前增设一个 **中断屏蔽触发器 MASK**。当 MASK 为 “1” 时，表示该中断源被屏蔽，中断请求不被响应。

​		屏蔽触发器同样既可以设置在接口电路中、也可以直接集成在 CPU 内。以 I/O 设备作为中断源为例，I/O 设备的接口电路中会有一个 **完成触发器 D**，它为 “1” 则表示设备已经处于就绪状态、要向 CPU 发出中断请求了。一般情况下，D 的输出可以直接接到中断请求触发器 INTR 的输入；现在则可以与 MASK 的输出经与非门之后、再交给 INTR。

<img src="C:/Users/18133/Desktop/课件/pictures/5_88_接口电路中的MASK和INTR.png" style="zoom:80%;" />

​		这样，当设备已经准备就绪（D = 1），且设备未被屏蔽（MASK = 0）时，来自 CPU 的中断查询信号就会将 INTR 置 “1”，表示该设备发出了中断请求信号。

​		同样，排队器内也可以加上屏蔽条件，就组成了具有屏蔽功能的排队器。例如集成在 CPU 内的排队器如果加上屏蔽功能，只需要另外将屏蔽信号也接入与非门就可以了：

<img src="C:/Users/18133/Desktop/课件/pictures/5_89_有屏蔽功能的排队器.png" style="zoom:70%;" />

##### 3. 屏蔽字和屏蔽技术

​		显然，对于每个中断源，中断请求触发器 INTR 和 中断屏蔽触发器 MASK 都是成对出现的。如果将所有屏蔽触发器组合在一起，也可以构成一个 **屏蔽寄存器**。屏蔽寄存器的内容就称为 **屏蔽字**。

​		屏蔽字可以在中断服务程序中进行设置，屏蔽字和中断源的优先级是一一对应的。以 16 个中断源 I~1~ ~ I~16~ 的屏蔽字为例，每个屏蔽字都是 16 位：

![](E:\source\jk-english\英语语法初级\图片\5_90_屏蔽字示例.png)

​		在不同中断源的中断服务程序中，可以设置适当的屏蔽字，就能对优先级不同的中断源进行屏蔽。

​		例如，在   I~1~ 的服务程序中，将屏蔽字设为全 1，就表示它的优先级最高：在响应 I~1~ 中断请求的过程中，不会再去响应任何新的请求（包括 I~1~ 自己发来的）；这相当于就是单重中断。而对于 I~3~ ，在服务程序中将屏蔽字前两位设为 0、后面为 1，表示 I~1~、I~2~ 优先级更高、不被屏蔽，而后面的中断源（包括自己）被屏蔽；于是开中断之后，I~1~、I~2~ 发来的新中断请求就可以打断当前 I~3~ 的中断服务程序，实现了多重中断。

##### 4. 改变处理优先级

​		使用屏蔽技术还可以改变中断源的优先等级。中断源的优先级，包括两层含义：**响应优先级** 和 **处理优先级**。

- 响应优先级：CPU 响应各中断源请求的先后次序，跟排队器有关，一般是硬件线路设定好的，不易改动；
- 处理优先级：CPU 实际执行中断服务程序的先后次序，可以通过屏蔽技术进行改动。

​		如果不采用屏蔽技术，那么处理的优先顺序就是按照响应优先级来的。例如，A、B、C、D 四个中断源，优先级别为 A > B > C > D，根据这一次序设计出排队器之后，当它们同时发来中断请求时，处理顺序就是响应顺序：

<img src="C:/Users/18133/Desktop/课件/pictures/5_91_不采用屏蔽技术的中断处理顺序.png" style="zoom:80%;" />

​		如果采用了屏蔽技术，就可以在不改变响应顺序的前提下，改变 CPU 处理中断的顺序。假如我们希望将它们的处理次序改为 A → D → C → B，那么每个中断源的中断服务程序中应该重新设置屏蔽字：

![](E:\source\jk-english\英语语法初级\图片\5_92_更改中断源的屏蔽字.png)

​		这样，同样还是 A、B、C、D 同时发出中断请求，这时的处理顺序就会变为：

<img src="C:/Users/18133/Desktop/课件/pictures/5_93_采用屏蔽技术改变中断处理顺序.png" style="zoom:80%;" />

​		显然，采用屏蔽技术改变处理优先级，需要在中断服务程序中重置屏蔽字。这样，中断服务程序的处理流程就会变为：

<img src="C:/Users/18133/Desktop/课件/pictures/5_94_中断服务程序流程.png" style="zoom:90%;" />

​		跟之前相比，增加了 **置屏蔽字** 和 **恢复屏蔽字** 两步操作。而为了防止在恢复阶段又出现新的中断，需要先关中断、等到恢复现场和屏蔽字之后再次开中断。

### 5.8 多处理器基本概念

#### 5.8.1 SISD、SIMD、MIMD 和向量处理器

​		通过改进系统结构，可以有效地提升计算机的性能，一个方向就是 **并行处理**。指令流水线就是一种典型的并行处理技术，它提供的是 **指令** 的并行；而另一种思路则是考虑让 **数据** 的处理并行起来。

##### 1. 费林分类法

​		美国计算机科学家迈克尔 · 费林（Michael Flynn）根据指令和数据是否并行，将计算机体系结构分为四类：

<img src="C:/Users/18133/Desktop/课件/pictures/5_95_费林分类法.png" style="zoom:80%;" />

- **SISD（Single Instruction stream, Single Data stream）**：**单指令流单数据流**。普通的串行执行结构，CPU 同时只能执行一条指令，处理一条数据；
- **SIMD（Single Instruction stream,  Multiple Data streams）**：**单指令流多数据流**。单条指令可以同时对应处理多个数据，从而实现了数据的并行处理；
- **MISD（Multiple Instruction streams, Single Data stream）**：**多指令流单数据流**。多条指令同时执行，但只处理一条数据，这种架构非常罕见，只是作为一种理论模型；
- **MIMD（Multiple Instruction streams, Multiple Data streams）**：**多指令流多数据流**。同时执行多条不同的指令，它们分别处理不同的数据；这种方式实现了线程、指令和数据的全方位并行处理。

##### 2. SIMD 和向量处理器

​		SIMD 的特点是，设置了多个并行的执行单元，而所有的执行单元都是同步的，执行的指令从同一个 PC 中取出，由同一个控制单元来进行调度管理。SIMD 对应的程序设计风格可以跟 SISD 非常相近，但要求程序中必须存在大量同构的数据，以便实现 **数据级并行**。

​		向量处理器是 SIMD 架构的一种具体实现，可以并行执行一组数据（**向量**）的计算任务。

​		向量处理器的基本原理是，从主存中收集数据，将它们按照顺序放到一组 **向量寄存器** 中，使用流水线式的执行单元在寄存器中依次进行操作，然后将结果写回主存。

#### 5.8.2 硬件多线程

​		相比 SIMD，MIMD 提高了更高的并行程度。MIMD 需要同时执行不同的指令流，这就要依赖多个 **进程（process）** 或者 **线程（thread）** 同时执行，让处理器时刻保持忙碌状态。

​		对于一个处理器，可以允许多个线程以重叠的方式，共享处理器的功能部件；当一个线程停顿时，就切换到另一个线程，从而更加充分地利用了硬件资源。这种技术就称为 **硬件多线程**（hardware multithreading）。

​		在支持硬件多线程的 CPU 中，需要为每个线程提供单独的寄存器堆和 PC 等资源，这样就可以在共享资源的同时保持线程的独立状态。

​		硬件多线程主要有两种实现方法。

- **细粒度多线程**

​		每条指令执行后就进行线程切换，从而实现多线程在时间上的交叉执行。这种交叉执行是轮转进行的，并且会跳过停顿的任何线程。

- **粗粒度多线程**

​		仅在发生高开销的停顿时（例如末级 cache 失效），才进行线程切换。对于流水线中的停顿，需要清空或者冻结流水线，因此流水线的重启开销比较大。

​		除此之外，硬件多线程还可以结合流水线多发技术，进一步降低成本、提高并行效率，这就是 **同时多线程**（Simultaneous Multithreading，**SMT**）。同时多线程是硬件多线程的一种变体，它结合使用多发射、动态调度流水线的处理器资源，来实现 **线程级** 和 **指令级** 并行。

​		英特尔（Intel）公司的 “ **超线程** “（Hyper-Threading）技术，就是一种在单个 CPU 上实现硬件多线程的方式。

#### 5.8.3 多核处理器和 SMP

##### 1. 多核处理器

​		另一种实现线程级并行的方式，就是在一个处理器芯片上，集成多个处理单元。为了区分不同的概念，每个处理单元就称为一个 ” **核** “（core），有多个核的处理器就被称为 **多核处理器**。

​		要想充分利用多核处理器的性能，应该采用多线程的方式执行程序。这样，多个线程可以在不同的核上并行执行，大大提升运行效率。

​		多核处理器一般也采用硬件多线程技术，为了进行区分，有时会将单个核心上同时运行多个线程称为有多个 ”**逻辑内核**“，而对应的真正的核心则称为 ”**物理内核**“。

<img src="C:/Users/18133/Desktop/课件/pictures/5_96_逻辑内核和物理内核.png" style="zoom:80%;" />

​		在多核处理器中，一般所有内核会有自己独立的寄存器和 L1、L2 缓存，而共享更低级的 cache（L3）和主存。

<img src="C:/Users/18133/Desktop/课件/pictures/5_97_多核处理器.png" style="zoom:80%;" />

​		如果不对处理单元进行集成，也可以用同样的架构将多个处理器联合在一起，这就是所谓的 **多处理器**。广义上讲，多核处理器也是一种多处理器。

##### 2. 共享内存多处理器（SMP）

​		编写运行在多处理器上的并行程序会更加复杂。在架构上，一个很重要的影响因素是，是否为所有处理器提供一个共享的统一物理地址空间；换句话说，所有处理器（核心）是否可以访问同一个主存储器。于是多处理器又可以划分为两种架构。

​		**共享内存多处理器**（Shared Memory Processor，**SMP**）为所有处理器提供统一的物理地址空间。处理器通过存储器中的 **共享变量** 进行通信，所有处理器都能通过加载（Load）和存储（Store）指令访问任意的主存位置。

![](E:\source\jk-english\英语语法初级\图片\5_98_SMP典型结构.png)

​		尽管物理地址空间是统一的、共享的，但如果存储器本身也采取了并行架构（例如多模块存储器），不同的处理器对存储器不同部分的访问可能就会有区分。因此 SMP 又可以有两种类型。

- **统一内存访问**（Unified Memory Access，**UMA**）多处理器

​		不管是来自哪个处理器的访存指令，延迟都是一致的。这样，每个处理器对所有存储单元的访问时间都大致相同，是对称的系统架构。

- **非统一内存访问**（Non-Unified Memory Access，**NUMA**）多处理器

​		访存指令的延迟不一致，取决于哪个处理器去访问哪个存储单元。一般架构中，每个处理器（CPU）会单独直接连接一部分主存，称为 **本地内存**；其它主存部分则通过总线进行访问，称为 **远程内存**。

##### 3. MPP 和集群

​		如果不采用共享内存的方式，而是让每个处理器都拥有私有的地址空间，这样就可以让各个处理器更加独立、获得更好的并行性和可扩展性。这种架构被称为 **大规模并行处理**（Massive Parallel Processing，**MPP**）。

![](E:\source\jk-english\英语语法初级\图片\5_99_MPP典型结构.png)

​		采用 MPP 架构的多处理器，必须通过显式的 **消息传递** 进行通信，因此传统上也把这种类型的计算机称为 **显式消息传递计算机**。

​		更进一步，我们可以通过标准网络交换机上的 I/O 接口进行连接，用一组计算机的集合来构建出消息传递多处理器，这种形式就被称为 **集群**（**Cluster**）。集群是一种分布式系统，已经成为如今并行处理计算机最典型的架构，也是大数据领域的技术基础。

### 5.9 章节练习

#### 一、单项选择题 

1. 【2011真题】假定不采用 Cache 和指令预取技术，且机器处于“开中断” 状态，则在下列有关指令执行的叙述中， 错误的是 	（    ）

​		A．每个指令周期中 CPU 都至少访问内存一次

​		B．每个指令周期一定大于或等于一个 CPU 时钟周期

​		C．空操作指令的指令周期中任何寄存器的内容都不会被改变

​		D．当前程序在每条指令执行结束时都可能被外部中断打断 

​		答案：C

​		要点：每个指令执行完成后，PC的值都会改变，从而可以继续执行下一条指令；即使是空操作也会执行 PC + 1 的动作。

2. 【2016真题】单周期处理器中所有指令的指令周期为一个时钟周期。下列关于单周期处理器的叙述中，错误的是	（    ）

​		A．可以采用单总线结构数据通路

​		B．处理器时钟频率较低

​		C．在指令执行过程中控制信号不变

​		D．每条指令的 CPI 为 1 

​		答案：A

​		要点：单总线结构下，所有部件需要争用唯一的总线，不支持并发传送操作；因此单周期处理器不可以采用单总线结构数据通路。

3. 【2019真题】下列有关处理器时钟脉冲信号的叙述中，错误的是	（    ）

​		A．时钟脉冲信号由机器脉冲源发出的脉冲信号经整形和分频后形成

​		B．时钟脉冲信号的宽度称为时钟周期，时钟周期的倒数为机器主频

​		C．时钟周期以相邻状态单元间组合逻辑电路的最大延迟为基准确定

​		D．处理器总是在每来一个时钟脉冲信号时就开始执行一条新的指令 

​		答案：D

​		要点：CPU 从内存中取出并执行一条指令所需的全部时间称为指令周期，指令周期又由若干机器周期组成，一个机器周期又包含若干时钟周期。

4. 【2020真题】下列给出的处理器类型中，理想情况下，CPI 为 1 的是	（    ）

   Ⅰ.单周期 CPU		Ⅱ.多周期 CPU		Ⅲ.基本流水线 CPU		Ⅳ.超标量流水线 CPU

   A. 仅Ⅰ、Ⅱ				B. 仅Ⅰ、Ⅲ				C. 仅Ⅱ、Ⅳ				D. 仅Ⅲ、Ⅳ

   答案：B

​		要点：多周期 CPU 指的是将整个 CPU 的执行过程分成几个阶段，每个阶段用一个时钟周期去完成，然后开始下一条指令的执行，而每种指令执行时所用的时钟数可以不同。基本流水线理想情况下 CPI 为 1；而超标量流水线可以通过增加功能部件实现并行，CPI 可以小于1。

5. 【2009真题】某计算机的指令流水线由四个功能段组成，指令流经各功能段的时间（忽略各功能段之间的缓存时间）分别为 90ns、 80ns、 70ns 和 60ns，则该计算机的 CPU 时钟周期至少是 	（    ）

​		A． 90ns 	B． 80ns 	C． 70ns 	D． 60ns

​		答案：A

6. 【2010真题】下列选项中， 不会引起指令流水线阻塞的是	（    ）

​		A．数据旁路（转发）			B．数据相关			C．条件转移 			D．资源冲突

​		答案：A

​		要点：数据旁路技术是解决数据冒险的一种方法。

7. 【2016真题】在无转发机制的五段基本流水线（取指、译码/读寄存器、运算、访存、写回寄存器）中，下列指令序列存在数据冒险的指令对是	（    ） 

```		
I1： add R1， R2， R3; （R2） +（R3） → R1
I2： add R5， R2， R4; （R2） +（R4） → R5
I3： add R4， R5， R3; （R5） +（R3） → R4
I4： add R5， R2， R6; （R2） +（R6） → R5  
```

​		A． I1 和 I2		 			B． I2 和 I3				 	C． I2 和 I4				 	D． I3 和 I4 

​		答案：B

​		要点：数据冒险也叫数据相关，指在程序中存在必须等前条指令执行完才能执行后一条指令的情况。

8. 【2017真题】下列关于超标量流水线特性的叙述中，正确的是	（    ）

​		Ⅰ . 能缩短流水线功能段的处理时间

​		Ⅱ．能在一个时钟周期内同时发射多条指令

​		Ⅲ．能结合动态调度技术提高指令执行并行性

​		A．仅Ⅱ 				B．仅Ⅰ、Ⅲ 				C．仅Ⅱ、Ⅲ 				D．Ⅰ、Ⅱ和Ⅲ 

​		答案：C

​		要点：超标量流水线每个时钟周期可以并行完成一条以上的指令，但不能缩短功能段的处理时间。

9. 【2018真题】若某计算机最复杂指令的执行需要完成 5 个子功能，分别由功能部件 A~E 实现，各功能部件所需时间分别为 80ps、50ps、50ps、70ps 和 50ps，采用流水线方式执行指令，流水段寄存器延时为 20ps，则CPU 时钟周期至少为	（    ）

​		A.60 ps						B.70 ps							C.80 ps						D.100 ps

​		答案：D

​		要点：流水线上每个流水段的时间相同，应该取最大的功能部件运行时间，并且加上寄存器的延时。

10. 【2019真题】在采用 “取指、译码/取数、执行、访存、写回”  5 段流水线的处理器中，执行如下指令序列，其中 s0、 s1、 s2、 s3 和 t2 表示寄存器编号。 

```
I1： add s2,s1,s0 	// R[s2] ← R[s1] + R[s0]
I2： load s3,0(t2) 	// R[s3] ← M[R[t2]+0]
I3： add s2,s2,s3 	// R[s2] ← R[s2] + R[s3]
I4： store s2,0(t2) 	// M[R[t2]+0] ← R[s2]
```

​		下列指令对中，不存在数据冒险的是 	（    ）

​		A．I1和 I3 				B． I2 和 I3			 	C． I2 和 I4 				D． I3 和 I4 

​		答案：C

​		要点：A、B、D 选项的指令对都发生了 “写后读” 的情况，存在数据冒险。

11. 【2021真题】下列关于数据通路的叙述中，错误的是	（    ）

​		A.数据通路包含 ALU 等组合逻辑（操作）元件

​		B.数据通路包含寄存器等时序逻辑（状态）元件

​		C.数据通路不包含用于异常事件检测及响应的电路

​		D.数据通路中的数据流动路径由控制信号进行控制

​		答案：C

​		要点：指令执行过程中数据所经过的路径， 包括路径上的部件， 称为数据通路。 ALU、通用寄存器、状态寄存器、Cache、MMU、浮点运算逻辑、异常和中断处理逻辑等， 都是指令执行过程中数据流经的部件， 都属于数据通路的一部分。 

12. 【2009真题】相对于微程序控制器，硬布线控制器的特点是	（    ） 

​		A．指令执行速度慢，指令功能的修改和扩展容易 

​		B．指令执行速度慢，指令功能的修改和扩展难

​		C．指令执行速度快，指令功能的修改和扩展容易

​		D．指令执行速度快，指令功能的修改和扩展难 

​		答案：D

13. 【2017真题】下列关于主存储器（MM）和控制存储器（CS）的叙述中，错误的是	（    ）

​		A． MM 在 CPU 外， CS 在 CPU 内

​		B． MM 按地址访问， CS 按内容访问

​		C． MM 存储指令和数据， CS 存储微指令

​		D． MM 用 RAM 和 ROM 实现， CS 用 ROM 实现

​		答案：B

​		要点：控制存储器按照微指令的地址访问。

14. 【2012真题】某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有 33 个微命令，构成 5 个互斥类，分别包含 7、 3、 12、 5 和 6 个微命令，则操作控制字段至少有 	（    ）

​		A. 5 位				 B. 6 位 				C. 15 位			 	D. 33 位 

​		答案：C

15. 【2014真题】某计算机采用微程序控制器，共有 32 条指令， 公共的取指令微程序包含 2 条微指令，各指令对应的微程序平均由 4 条微指令组成，采用断定法（下地址字段法）确定下条微指令地址， 则微指令中下地址字段的位数至少是	（    ）

​		A. 5						 B. 6						 C. 8						 D. 9 

​		答案：C

​		要点：微指令下地址字段的位数，与微指令的条数有关。总共有 4 × 32 + 2 = 130 条微指令。

16. 【2020真题】下列关于“自陷”(Trap，也称陷阱)的叙述中，错误的是	（    ）

​		A.自陷是通过陷阱指令预先设定的一类外部中断事件

​		B.自陷可用于实现程序调试时的断点设置和单步跟踪

​		C.自陷发生后CPU将转去执行操作系统内核相应程序

​		D.自陷处理完成后返回到陷阱指令的下一条指令执行

​		答案：A

​		要点：自陷产生于 CPU 内部，属于内中断。

17. 【2009真题】下列选项中，能引起外部中断的事件是	（    ）  

​		A．键盘输入  					B．除数为 0 				C．浮点运算下溢   				D．访存缺页

​		答案：A

18. 【2015真题】内部异常（内中断）可分为故障（fault）、陷阱（trap）和终止（abort）三类。下列有关内部异常的叙述中，错误的是	（    ）

​		A．内部异常的产生与当前执行指令相关						B．内部异常的检测由CPU内部逻辑实现

​		C．内部异常的响应发生在指令执行过程中					D．内部异常处理后返回到发生异常的指令继续执行 

​		答案：D

19. 【2017真题】下列关于多重中断系统的叙述中， 错误的是	（    ）

​		A．在一条指令执行结束时响应中断						B．中断处理期间 CPU 处于关中断状态

​		C．中断请求的产生与当前指令的执行无关			D． CPU通过采样中断请求信号检测中断请求 

​		答案：B

​		要点：实现多重中断，中断处理期间必须开中断。

20. 【2022真题】下列关于并行处理技术的叙述中，不正确的是	（    ） 

​		A. 多核处理器属于 MIMD 结构							B. 向量处理器属于 SIMD 结构

​		C. 硬件多线程技术只可用于多核处理器				D. SMP 中所有处理器共享单一物理地址空间 

​		答案：C

#### 二、综合应用题

1. 【2014真题】某程序中有如下循环代码段P: 

```
for(int i = 0; i < N; i++) sum+=A[i];
```

​		假设编译时变量 sum 和 i 分别分配在寄存器 R1 和 R2 中。常量 N 在寄存器 R6 中，数组 A 的首地址在寄存器 R3 中 。 程序段 P 起始地址为 0804 8100H，对应的汇编代码和机器代码如下表所示。 

![1687845561989](E:\source\jk-english\英语语法初级\图片\5_100_14年真题题图1.png)

​		执行上述代码的计算机 M 采用 32 位定长指令字， 其中分支指令 bne 采用如下格式： 

![1687845584694](E:\source\jk-english\英语语法初级\图片\5_101_14年真题题图2.png)

​		OP 为操作码；Rs 和 Rd 为寄存器编号；OFFSET 为偏移量，用补码表示。 请回答下列问题，并说明理由。

​		1）M 的存储器编址单位是什么？

​		2）已知 sll 指令实现左移功能， 数组 A 中每个元素占多少位？

​		3）表中 bne 指令的 OFFSET 字段的值是多少？已知 bne 指令采用相对寻址方式， 当前 PC 内容为 bne 指令地址， 通过分析表中指令地址和 bne 指令内容 ， 推断出 bne 指令的转移目标地址计算公式。

​		4）若 M 采用如下 “按序发射、按序完成” 的 5级指令流水线： IF (取值 ）、ID (译码及取数）、 EXE (执行）、 MEM (访存）、 WB (写回寄存器 ），且硬件不采取任何转发措施， 分支指令的执行均引起 3个时钟周期的阻塞， 则 P 中哪些指令的执行会由于数据相关而发生流水线阻塞？哪条指令的执行会发生控制冒险？为什么指令 1 的执行不会因为与指令 5 的数据相关而发生阻塞？ 

​		**答案：**

​		1）M 的存储器编址单位为字节。因为 M 采用 32 位定长指令字，每个指令占 4 个字节；而指令间的地址差为 4，所以每个地址对应 1 个字节。

​		2）A 中每个元素占 32 位。左移 2 位相当于乘以 4，所以每个元素占 4 个字节。

​		3）bne 指令 OFFSET 字段的机器补码为 FFFAH，真值为 -6。正常情况下，OFFSET 乘以指令字长就应该是偏移的地址差：
$$
OFFSET × 4 = -6 × 4 = -24
$$
​		不过在这里，bne 指令地址和要跳转到的 loop 地址差为
$$
0804 8100H - 0804 8114H = -14H = (-20)_{10}
$$
​		所以很明显，发生跳转的时候，应该基于 bne 下一条指令的地址 0804 8118H ，再加上 OFFSET × 4，就是转移的目标地址。相当于 PC 先做了 +1 操作（对应地址 +4）：
$$
(PC)+4+OFFSET×4
$$
​		4）由于数据相关而发生阻塞的指令为第 2、 3、 4、 6 条，因为第 2、 3、 4、 6 条指令都与各自前一条指令发生数据相关。

​		第 6 条指令会发生控制冒险。

![](E:\source\jk-english\英语语法初级\图片\5_102_14年真题题解.png)

​		当前循环的第 5 条指令与下次循环的第 1 条指令虽然有数据相关，但由于第 6 条指令后有 3 个时钟周期的阻塞，因而消除了该数据相关。

---

2. 【2022真题】某 CPU 中部分数据通路如图所示， 其中， GPRs 为通用寄存器组；FR 为标志寄存器，用于存放 ALU 产生的标志信息；带箭头虚线表示控制信号，如控制信号 Read、Write 分别表示主存读、 主存写， MDRin表示内部总线上数据写入MDR，MDRout 表示 MDR 的内容送内部总线。

![1688018812061](E:\source\jk-english\英语语法初级\图片\5_103_22年真题题图1.png)

​		请回答下列问题。

​		1）设 ALU 的输入端 A、 B 及输出端 F 的最高位分别为 A<sub>15</sub> 、 B<sub>15</sub> 及 F<sub>15</sub> ,  FR 中的符号标志和溢出标志分别为 SF 和 OF，则 SF 的逻辑表达式是什么？A 加 B、 A 减 B 时 OF 的逻辑表达式分别是什么？要求逻辑表达式的输入变量为 A<sub>15</sub> 、 B<sub>15</sub> 及 F<sub>15</sub>。

​		2）为什么要设置暂存器 Y 和 Z?

​		3）若 GPRs 的输入端 rs、 rd 分别为所读、 写的通用寄存器的编号， 则 GPRs 中最多有多少个通用寄存器？rs 和 rd 来自图中的哪个寄存器？已知 GPRs 内部有一个地址译码器和一个多路选择器， rd 应连接地址译码器还是多路选择器？

​		4）取指令阶段（不考虑 PC 增量操作） 的控制信号序列是什么？若从发出主存读命令到主存读出数据并传送到 MDR 共需5个时钟周期， 则取指令阶段至少需要几个时钟周期？

​		5）图中控制信号由什么部件产生？图中哪些寄存器的输出信号会连到该部件的输入端？ 

​		**答案：**

​		1）SF 表示运算结果的正负性，所以  SF = F~15~

​			A 加 B 时，A + B → F。若 A 和 B 都为负且 F 为正；或者，若 A 和 B 都为正且 F 为负，则溢出。所以溢出标志逻辑表达式为：
$$
OF = A_{15} \cdot B_{15} \cdot \overline{F_{15}} + \overline{A_{15}} \cdot \overline{B_{15}} \cdot F_{15}
$$
​			A 减 B 时，A - B → F。若 A 为负、B 为正，同时 F 为正，则溢出；或者，若 A 为正、B 为负，同时 F 为负，则溢出。所以溢出标志逻辑表达式为：
$$
OF = A_{15} \cdot \overline{B_{15}} \cdot \overline{F_{15}} + \overline{A_{15}} \cdot {B_{15}} \cdot F_{15}
$$
​		2）因为在单总线结构中，每个时刻总线上只有一个数据有效，而 ALU 有两个输入端和一个输出端。因此，当 ALU 运算时，首先需要用暂存器 Y 缓存其中一个输入端的数据，在通过总线传送另一个输入端的数据。当ALU的输出端产生运算结果，但由于该节拍总线被占用，因此需要暂存器 Z，用来缓存 ALU 的输出端数据。

​		3）可以看到 rs 和 rd 的编号都为 4 位，那么 GPRs 中最多有 2^4^ = 16 个通用寄存器。

​			寄存器编号用于在指令中表示寄存器寻址的地址，指令寄存器 IR 中存储指令，所以 rs 和 rd 来自指令寄存器IR。

​			rd 是寄存器编号，应该连接地址译码器。多路选择器用于从多个输入信号中选择一个输出，它的输出信号取决于控制信号。

​		4）取指阶段微操作：

![](E:\source\jk-english\英语语法初级\图片\5_46_取指周期节拍安排.png)

​			对应的控制信号序列如下：

​			① PCout, MARin 有效，将指令的地址写入 MAR

​			② Read 信号有效，读取主存数据（经系统总线写入MDR）

​			③ MDRout，IRin 有效，将 MDR 的内容写入指令寄存器 IR

​			其它步骤省略。

​			步骤 ① 需要1个时钟周期，步骤 ② 需要 5 个时钟周期，步骤 ③ 需要1个时钟周期，因此取指令阶段至少需要7 个时钟周期。

​		5）图中控制信号由控制单元CU产生。

​			指令寄存器 IR 和标志寄存器 FR 的输出信号会连接到控制部件的输入端。